!function(n,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.rrule=e():n.rrule=e()}("undefined"!=typeof self?self:this,function(){return function(n){var e={};function t(r){if(e[r])return e[r].exports;var s=e[r]={i:r,l:!1,exports:{}};return n[r].call(s.exports,s,s.exports,t),s.l=!0,s.exports}return t.m=n,t.c=e,t.d=function(n,e,r){t.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:r})},t.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t.t=function(n,e){if(1&e&&(n=t(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var s in n)t.d(r,s,function(e){return n[e]}.bind(null,s));return r},t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,"a",e),e},t.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},t.p="",t(t.s=1)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "range", function() { return range; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "repeat", function() { return repeat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "split", function() { return split; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pymod", function() { return pymod; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divmod", function() { return divmod; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "plb", function() { return plb; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "contains", function() { return contains; });\n// =============================================================================\n// Helper functions\n// =============================================================================\n\n/**\n * Simplified version of python\'s range()\n */\nconst range = function (start, end) {\n  if (arguments.length === 1) {\n    end = start\n    start = 0\n  }\n  const rang = []\n  for (let i = start; i < end; i++) rang.push(i)\n  return rang\n}\n\nconst repeat = function (value, times) {\n  let i = 0\n  const array = []\n\n  if (value instanceof Array) {\n    for (; i < times; i++) array[i] = [].concat(value)\n  } else {\n    for (; i < times; i++) array[i] = value\n  }\n  return array\n}\n\n/**\n * Python like split\n */\nconst split = function (str, sep, num) {\n  const splits = str.split(sep)\n  return num\n    ? splits.slice(0, num).concat([splits.slice(num).join(sep)]) : splits\n}\n\n/**\n * closure/goog/math/math.js:modulo\n * Copyright 2006 The Closure Library Authors.\n * The % operator in JavaScript returns the remainder of a / b, but differs from\n * some other languages in that the result will have the same sign as the\n * dividend. For example, -1 % 8 == -1, whereas in some other languages\n * (such as Python) the result would be 7. This function emulates the more\n * correct modulo behavior, which is useful for certain applications such as\n * calculating an offset index in a circular list.\n *\n * @param {number} a The dividend.\n * @param {number} b The divisor.\n * @return {number} a % b where the result is between 0 and b (either 0 <= x < b\n *     or b < x <= 0, depending on the sign of b).\n */\nconst pymod = function (a, b) {\n  const r = a % b\n  // If r and b differ in sign, add b to wrap the result to the correct sign.\n  return (r * b < 0) ? r + b : r\n}\n\n/**\n * @see: <http://docs.python.org/library/functions.html#divmod>\n */\nconst divmod = function (a, b) {\n  return {div: Math.floor(a / b), mod: pymod(a, b)}\n}\n\n/**\n * Python-like boolean\n * @return {Boolean} value of an object/primitive, taking into account\n * the fact that in Python an empty list\'s/tuple\'s\n * boolean value is False, whereas in JS it\'s true\n */\nconst plb = function (obj) {\n  return (obj instanceof Array && obj.length === 0)\n    ? false : Boolean(obj)\n}\n\n/**\n * Return true if a value is in an array\n */\nconst contains = function (arr, val) {\n  return arr.indexOf(val) !== -1\n}\n\n\n\n\n//# sourceURL=webpack://rrule/./src/helpers.js?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./src/weekday.js\nconst WDAYS = ['MO', 'TU', 'WE', 'TH', 'FR', 'SA', 'SU']\n\n// =============================================================================\n// Weekday\n// =============================================================================\n\nclass Weekday {\n  constructor (weekday, n) {\n    if (n === 0) throw new Error(\"Can't create weekday with n == 0\")\n    this.weekday = weekday\n    this.n = n\n  }\n\n  // __call__ - Cannot call the object directly, do it through\n  // e.g. RRule.TH.nth(-1) instead,\n  nth (n) {\n    return this.n === n ? this : new Weekday(this.weekday, n)\n  }\n\n  // __eq__\n  equals (other) {\n    return this.weekday === other.weekday && this.n === other.n\n  }\n\n  // __repr__\n  toString () {\n    let s = WDAYS[this.weekday]\n    if (this.n) s = (this.n > 0 ? '+' : '') + String(this.n) + s\n    return s\n  }\n\n  getJsWeekday () {\n    return this.weekday === 6 ? 0 : this.weekday + 1\n  }\n}\n\n// CONCATENATED MODULE: ./src/dateutil.js\n/**\n * General date-related utilities.\n * Also handles several incompatibilities between JavaScript and Python\n *\n */\nconst dateutil = {\n  MONTH_DAYS: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],\n\n  /**\n   * Number of milliseconds of one day\n   */\n  ONE_DAY: 1000 * 60 * 60 * 24,\n\n  /**\n   * @see: <http://docs.python.org/library/datetime.html#datetime.MAXYEAR>\n   */\n  MAXYEAR: 9999,\n\n  /**\n   * Python uses 1-Jan-1 as the base for calculating ordinals but we don't\n   * want to confuse the JS engine with milliseconds > Number.MAX_NUMBER,\n   * therefore we use 1-Jan-1970 instead\n   */\n  ORDINAL_BASE: new Date(1970, 0, 1),\n\n  /**\n   * Python: MO-SU: 0 - 6\n   * JS: SU-SAT 0 - 6\n   */\n  PY_WEEKDAYS: [6, 0, 1, 2, 3, 4, 5],\n\n  /**\n   * py_date.timetuple()[7]\n   */\n  getYearDay: function (date) {\n    const dateNoTime = new Date(\n      date.getFullYear(), date.getMonth(), date.getDate())\n    return Math.ceil(\n      (dateNoTime - new Date(date.getFullYear(), 0, 1)) / dateutil.ONE_DAY) + 1\n  },\n\n  isLeapYear: function (year) {\n    return ((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0)\n  },\n\n  /**\n   * @return {Number} the date's timezone offset in ms\n   */\n  tzOffset: function (date) {\n    return date.getTimezoneOffset() * 60 * 1000\n  },\n\n  /**\n   * @see: <http://www.mcfedries.com/JavaScript/DaysBetween.asp>\n   */\n  daysBetween: function (date1, date2) {\n    // The number of milliseconds in one day\n    // Convert both dates to milliseconds\n    const date1ms = date1.getTime() - dateutil.tzOffset(date1)\n    const date2ms = date2.getTime() - dateutil.tzOffset(date2)\n    // Calculate the difference in milliseconds\n    const differencems = date1ms - date2ms\n    // Convert back to days and return\n    return Math.round(differencems / dateutil.ONE_DAY)\n  },\n\n  /**\n   * @see: <http://docs.python.org/library/datetime.html#datetime.date.toordinal>\n   */\n  toOrdinal: function (date) {\n    return dateutil.daysBetween(date, dateutil.ORDINAL_BASE)\n  },\n\n  /**\n   * @see - <http://docs.python.org/library/datetime.html#datetime.date.fromordinal>\n   */\n  fromOrdinal: function (ordinal) {\n    const millisecsFromBase = ordinal * dateutil.ONE_DAY\n    return new Date(dateutil.ORDINAL_BASE.getTime() -\n      dateutil.tzOffset(dateutil.ORDINAL_BASE) +\n      millisecsFromBase +\n      dateutil.tzOffset(new Date(millisecsFromBase)))\n  },\n\n  /**\n   * @see: <http://docs.python.org/library/calendar.html#calendar.monthrange>\n   */\n  monthRange: function (year, month) {\n    const date = new Date(year, month, 1)\n    return [dateutil.getWeekday(date), dateutil.getMonthDays(date)]\n  },\n\n  getMonthDays: function (date) {\n    const month = date.getMonth()\n    return month === 1 && dateutil.isLeapYear(date.getFullYear())\n      ? 29 : dateutil.MONTH_DAYS[month]\n  },\n\n  /**\n   * @return {Number} python-like weekday\n   */\n  getWeekday: function (date) {\n    return dateutil.PY_WEEKDAYS[date.getDay()]\n  },\n\n  /**\n   * @see: <http://docs.python.org/library/datetime.html#datetime.datetime.combine>\n   */\n  combine: function (date, time) {\n    time = time || date\n    return new Date(\n      date.getFullYear(), date.getMonth(), date.getDate(),\n      time.getHours(), time.getMinutes(), time.getSeconds(),\n      time.getMilliseconds())\n  },\n\n  clone: function (date) {\n    const dolly = new Date(date.getTime())\n    return dolly\n  },\n\n  cloneDates: function (dates) {\n    const clones = []\n    for (let i = 0; i < dates.length; i++) {\n      clones.push(dateutil.clone(dates[i]))\n    }\n    return clones\n  },\n\n  /**\n   * Sorts an array of Date or dateutil.Time objects\n   */\n  sort: function (dates) {\n    dates.sort(function (a, b) {\n      return a.getTime() - b.getTime()\n    })\n  },\n\n  timeToUntilString: function (time) {\n    let comp\n    const date = new Date(time)\n    const comps = [\n      date.getUTCFullYear(),\n      date.getUTCMonth() + 1,\n      date.getUTCDate(),\n      'T',\n      date.getUTCHours(),\n      date.getUTCMinutes(),\n      date.getUTCSeconds(),\n      'Z'\n    ]\n\n    for (let i = 0; i < comps.length; i++) {\n      comp = comps[i]\n      if (!/[TZ]/.test(comp) && comp < 10) comps[i] = '0' + String(comp)\n    }\n    return comps.join('')\n  },\n\n  untilStringToDate: function (until) {\n    const re = /^(\\d{4})(\\d{2})(\\d{2})(T(\\d{2})(\\d{2})(\\d{2})Z?)?$/\n    const bits = re.exec(until)\n    if (!bits) throw new Error('Invalid UNTIL value: ' + until)\n    return new Date(Date.UTC(\n      bits[1],\n      bits[2] - 1,\n      bits[3],\n      bits[5] || 0,\n      bits[6] || 0,\n      bits[7] || 0))\n  }\n}\n\nclass Time {\n  constructor (hour, minute, second, millisecond) {\n    this.hour = hour\n    this.minute = minute\n    this.second = second\n    this.millisecond = millisecond || 0\n  }\n\n  getHours () {\n    return this.hour\n  }\n\n  getMinutes () {\n    return this.minute\n  }\n\n  getSeconds () {\n    return this.second\n  }\n\n  getMilliseconds () {\n    return this.millisecond\n  }\n\n  getTime () {\n    return ((this.hour * 60 * 60) + (this.minute * 60) + this.second) * 1000 +\n      this.millisecond\n  }\n}\n\ndateutil.Time = Time\n\n/* harmony default export */ var src_dateutil = (dateutil);\n\n// EXTERNAL MODULE: ./src/helpers.js\nvar helpers = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./src/masks.js\nconst { range, repeat } = __webpack_require__(0)\n\n// =============================================================================\n// Date masks\n// =============================================================================\n\n// Every mask is 7 days longer to handle cross-year weekly periods.\n\nconst M365MASK = [].concat(\n  repeat(1, 31), repeat(2, 28), repeat(3, 31),\n  repeat(4, 30), repeat(5, 31), repeat(6, 30),\n  repeat(7, 31), repeat(8, 31), repeat(9, 30),\n  repeat(10, 31), repeat(11, 30), repeat(12, 31),\n  repeat(1, 7))\n\nconst M366MASK = [].concat(\n  repeat(1, 31), repeat(2, 29), repeat(3, 31),\n  repeat(4, 30), repeat(5, 31), repeat(6, 30),\n  repeat(7, 31), repeat(8, 31), repeat(9, 30),\n  repeat(10, 31), repeat(11, 30), repeat(12, 31),\n  repeat(1, 7))\n\nlet M28 = range(1, 29)\nlet M29 = range(1, 30)\nlet M30 = range(1, 31)\nlet M31 = range(1, 32)\n\nconst MDAY366MASK = [].concat(\n  M31, M29, M31,\n  M30, M31, M30,\n  M31, M31, M30,\n  M31, M30, M31,\n  M31.slice(0, 7))\n\nconst MDAY365MASK = [].concat(\n  M31, M28, M31,\n  M30, M31, M30,\n  M31, M31, M30,\n  M31, M30, M31,\n  M31.slice(0, 7))\n\nM28 = range(-28, 0)\nM29 = range(-29, 0)\nM30 = range(-30, 0)\nM31 = range(-31, 0)\n\nconst NMDAY366MASK = [].concat(\n  M31, M29, M31,\n  M30, M31, M30,\n  M31, M31, M30,\n  M31, M30, M31,\n  M31.slice(0, 7))\n\nconst NMDAY365MASK = [].concat(\n  M31, M28, M31,\n  M30, M31, M30,\n  M31, M31, M30,\n  M31, M30, M31,\n  M31.slice(0, 7))\n\nconst M366RANGE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366]\nconst M365RANGE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365]\n\nconst WDAYMASK = (function () {\n  let wdaymask = []\n  for (let i = 0; i < 55; i++) wdaymask = wdaymask.concat(range(7))\n  return wdaymask\n}())\n\n\n\n// CONCATENATED MODULE: ./src/iterresult.js\n// =============================================================================\n// Results\n// =============================================================================\n\n/**\n * This class helps us to emulate python's generators, sorta.\n */\nclass IterResult {\n  constructor (method, args) {\n    this.method = method\n    this.args = args\n    this.minDate = null\n    this.maxDate = null\n    this._result = []\n\n    if (method === 'between') {\n      this.maxDate = args.inc\n        ? args.before : new Date(args.before.getTime() - 1)\n      this.minDate = args.inc\n        ? args.after : new Date(args.after.getTime() + 1)\n    } else if (method === 'before') {\n      this.maxDate = args.inc ? args.dt : new Date(args.dt.getTime() - 1)\n    } else if (method === 'after') {\n      this.minDate = args.inc ? args.dt : new Date(args.dt.getTime() + 1)\n    }\n  }\n\n  /**\n   * Possibly adds a date into the result.\n   *\n   * @param {Date} date - the date isn't necessarly added to the result\n   *                      list (if it is too late/too early)\n   * @return {Boolean} true if it makes sense to continue the iteration\n   *                   false if we're done.\n   */\n  accept (date) {\n    const tooEarly = this.minDate && date < this.minDate\n    const tooLate = this.maxDate && date > this.maxDate\n\n    if (this.method === 'between') {\n      if (tooEarly) return true\n      if (tooLate) return false\n    } else if (this.method === 'before') {\n      if (tooLate) return false\n    } else if (this.method === 'after') {\n      if (tooEarly) return true\n      this.add(date)\n      return false\n    }\n\n    return this.add(date)\n  }\n\n  /**\n   *\n   * @param {Date} date that is part of the result.\n   * @return {Boolean} whether we are interested in more values.\n   */\n  add (date) {\n    this._result.push(date)\n    return true\n  }\n\n  /**\n   * 'before' and 'after' return only one date, whereas 'all'\n   * and 'between' an array.\n   * @return {Date,Array?}\n   */\n  getValue () {\n    const res = this._result\n    switch (this.method) {\n      case 'all':\n      case 'between':\n        return res\n      case 'before':\n      case 'after':\n        return res.length ? res[res.length - 1] : null\n    }\n  }\n\n  clone () {\n    return new IterResult(this.method, this.args)\n  }\n}\n\n// CONCATENATED MODULE: ./src/callbackiterresult.js\n\n\n\n/**\n * IterResult subclass that calls a callback function on each add,\n * and stops iterating when the callback returns false.\n */\nclass callbackiterresult_CallbackIterResult extends IterResult {\n  constructor (method, args, iterator) {\n    const allowedMethods = ['all', 'between']\n    if (!Object(helpers[\"contains\"])(allowedMethods, method)) {\n      throw new Error('Invalid method \"' + method +\n        '\". Only all and between works with iterator.')\n    }\n\n    super(method, args)\n\n    this.iterator = iterator\n  }\n\n  add (date) {\n    if (this.iterator(date, this._result.length)) {\n      this._result.push(date)\n      return true\n    }\n    return false\n  }\n}\n\n// CONCATENATED MODULE: ./src/rrule.js\n\n\n\n\n\n\n\n\n\n// =============================================================================\n// RRule\n// =============================================================================\n\n/**\n *\n * @param {Object?} options - see <http://labix.org/python-dateutil/#head-cf004ee9a75592797e076752b2a889c10f445418>\n *        The only required option is `freq`, one of RRule.YEARLY, RRule.MONTHLY, ...\n * @constructor\n */\nclass rrule_RRule {\n  constructor (options, noCache) {\n    options = options || {}\n    // RFC string\n    this._string = null\n    this._cache = noCache ? null : {\n      all: false,\n      before: [],\n      after: [],\n      between: []\n    }\n\n    // used by toString()\n    this.origOptions = {}\n\n    this.options = {}\n\n    const invalid = []\n    const keys = Object.keys(options)\n    const defaultKeys = Object.keys(rrule_RRule.DEFAULT_OPTIONS)\n\n    // Shallow copy for options and origOptions and check for invalid\n    keys.forEach(function (key) {\n      this.origOptions[key] = options[key]\n      this.options[key] = options[key]\n      if (!Object(helpers[\"contains\"])(defaultKeys, key)) invalid.push(key)\n    }, this)\n\n    if (invalid.length) throw new Error('Invalid options: ' + invalid.join(', '))\n\n    if (!rrule_RRule.FREQUENCIES[options.freq] && options.byeaster === null) {\n      throw new Error('Invalid frequency: ' + String(options.freq))\n    }\n\n    // Merge in default options\n    defaultKeys.forEach(function (key) {\n      if (!Object(helpers[\"contains\"])(keys, key)) this.options[key] = rrule_RRule.DEFAULT_OPTIONS[key]\n    }, this)\n\n    const opts = this.options\n\n    if (opts.byeaster !== null) opts.freq = rrule_RRule.YEARLY\n    if (!opts.dtstart) opts.dtstart = new Date(new Date().setMilliseconds(0))\n\n    const millisecondModulo = opts.dtstart.getTime() % 1000\n    if (opts.wkst === null) {\n      opts.wkst = rrule_RRule.MO.weekday\n    } else if (typeof opts.wkst === 'number') {\n      // cool, just keep it like that\n    } else {\n      opts.wkst = opts.wkst.weekday\n    }\n\n    let v\n    if (opts.bysetpos !== null) {\n      if (typeof opts.bysetpos === 'number') opts.bysetpos = [opts.bysetpos]\n\n      for (let i = 0; i < opts.bysetpos.length; i++) {\n        v = opts.bysetpos[i]\n        if (v === 0 || !(v >= -366 && v <= 366)) {\n          throw new Error('bysetpos must be between 1 and 366,' +\n            ' or between -366 and -1')\n        }\n      }\n    }\n\n    if (!(Object(helpers[\"plb\"])(opts.byweekno) || Object(helpers[\"plb\"])(opts.byyearday) || Object(helpers[\"plb\"])(opts.bymonthday) ||\n      opts.byweekday !== null || opts.byeaster !== null)) {\n      switch (opts.freq) {\n        case rrule_RRule.YEARLY:\n          if (!opts.bymonth) opts.bymonth = opts.dtstart.getMonth() + 1\n          opts.bymonthday = opts.dtstart.getDate()\n          break\n        case rrule_RRule.MONTHLY:\n          opts.bymonthday = opts.dtstart.getDate()\n          break\n        case rrule_RRule.WEEKLY:\n          opts.byweekday = src_dateutil.getWeekday(opts.dtstart)\n          break\n      }\n    }\n\n    // bymonth\n    if (opts.bymonth !== null && !(opts.bymonth instanceof Array)) {\n      opts.bymonth = [opts.bymonth]\n    }\n    // byyearday\n    if (opts.byyearday !== null && !(opts.byyearday instanceof Array)) {\n      opts.byyearday = [opts.byyearday]\n    }\n\n    // bymonthday\n    if (opts.bymonthday === null) {\n      opts.bymonthday = []\n      opts.bynmonthday = []\n    } else if (opts.bymonthday instanceof Array) {\n      const bymonthday = []\n      const bynmonthday = []\n\n      for (let i = 0; i < opts.bymonthday.length; i++) {\n        v = opts.bymonthday[i]\n        if (v > 0) {\n          bymonthday.push(v)\n        } else if (v < 0) {\n          bynmonthday.push(v)\n        }\n      }\n      opts.bymonthday = bymonthday\n      opts.bynmonthday = bynmonthday\n    } else {\n      if (opts.bymonthday < 0) {\n        opts.bynmonthday = [opts.bymonthday]\n        opts.bymonthday = []\n      } else {\n        opts.bynmonthday = []\n        opts.bymonthday = [opts.bymonthday]\n      }\n    }\n\n    // byweekno\n    if (opts.byweekno !== null && !(opts.byweekno instanceof Array)) {\n      opts.byweekno = [opts.byweekno]\n    }\n\n    // byweekday / bynweekday\n    if (opts.byweekday === null) {\n      opts.bynweekday = null\n    } else if (typeof opts.byweekday === 'number') {\n      opts.byweekday = [opts.byweekday]\n      opts.bynweekday = null\n    } else if (opts.byweekday instanceof Weekday) {\n      if (!opts.byweekday.n || opts.freq > rrule_RRule.MONTHLY) {\n        opts.byweekday = [opts.byweekday.weekday]\n        opts.bynweekday = null\n      } else {\n        opts.bynweekday = [\n          [opts.byweekday.weekday, opts.byweekday.n]\n        ]\n        opts.byweekday = null\n      }\n    } else {\n      const byweekday = []\n      const bynweekday = []\n\n      for (let i = 0; i < opts.byweekday.length; i++) {\n        const wday = opts.byweekday[i]\n\n        if (typeof wday === 'number') {\n          byweekday.push(wday)\n        } else if (!wday.n || opts.freq > rrule_RRule.MONTHLY) {\n          byweekday.push(wday.weekday)\n        } else {\n          bynweekday.push([wday.weekday, wday.n])\n        }\n      }\n      opts.byweekday = Object(helpers[\"plb\"])(byweekday) ? byweekday : null\n      opts.bynweekday = Object(helpers[\"plb\"])(bynweekday) ? bynweekday : null\n    }\n\n    // byhour\n    if (opts.byhour === null) {\n      opts.byhour = (opts.freq < rrule_RRule.HOURLY) ? [opts.dtstart.getHours()] : null\n    } else if (typeof opts.byhour === 'number') {\n      opts.byhour = [opts.byhour]\n    }\n\n    // byminute\n    if (opts.byminute === null) {\n      opts.byminute = (opts.freq < rrule_RRule.MINUTELY)\n        ? [opts.dtstart.getMinutes()] : null\n    } else if (typeof opts.byminute === 'number') {\n      opts.byminute = [opts.byminute]\n    }\n\n    // bysecond\n    if (opts.bysecond === null) {\n      opts.bysecond = (opts.freq < rrule_RRule.SECONDLY)\n        ? [opts.dtstart.getSeconds()] : null\n    } else if (typeof opts.bysecond === 'number') {\n      opts.bysecond = [opts.bysecond]\n    }\n\n    if (opts.freq >= rrule_RRule.HOURLY) {\n      this.timeset = null\n    } else {\n      this.timeset = []\n      for (let i = 0; i < opts.byhour.length; i++) {\n        const hour = opts.byhour[i]\n        for (let j = 0; j < opts.byminute.length; j++) {\n          const minute = opts.byminute[j]\n          for (let k = 0; k < opts.bysecond.length; k++) {\n            const second = opts.bysecond[k]\n            // python:\n            // datetime.time(hour, minute, second,\n            // tzinfo=self._tzinfo))\n            this.timeset.push(new src_dateutil.Time(hour, minute, second, millisecondModulo))\n          }\n        }\n      }\n      src_dateutil.sort(this.timeset)\n    }\n  }\n\n  static parseText (text, language) {\n    return getnlp().parseText(text, language)\n  }\n\n  static fromText (text, language) {\n    return getnlp().fromText(text, language)\n  }\n\n  static parseString (rfcString) {\n    rfcString = rfcString.replace(/^\\s+|\\s+$/, '')\n    if (!rfcString.length) return null\n\n    let key, value, attr\n    const attrs = rfcString.split(';')\n    const options = {}\n\n    for (let i = 0; i < attrs.length; i++) {\n      attr = attrs[i].split('=')\n      key = attr[0]\n      value = attr[1]\n      switch (key) {\n        case 'FREQ':\n          options.freq = rrule_RRule[value]\n          break\n        case 'WKST':\n          options.wkst = rrule_RRule[value]\n          break\n        case 'COUNT':\n        case 'INTERVAL':\n        case 'BYSETPOS':\n        case 'BYMONTH':\n        case 'BYMONTHDAY':\n        case 'BYYEARDAY':\n        case 'BYWEEKNO':\n        case 'BYHOUR':\n        case 'BYMINUTE':\n        case 'BYSECOND':\n          if (value.indexOf(',') !== -1) {\n            value = value.split(',')\n            for (let j = 0; j < value.length; j++) {\n              if (/^[+-]?\\d+$/.test(value[j])) value[j] = Number(value[j])\n            }\n          } else if (/^[+-]?\\d+$/.test(value)) {\n            value = Number(value)\n          }\n          key = key.toLowerCase()\n          options[key] = value\n          break\n        case 'BYDAY': // => byweekday\n          let n, wday, day\n          const days = value.split(',')\n\n          options.byweekday = []\n          for (let j = 0; j < days.length; j++) {\n            day = days[j]\n            if (day.length === 2) { // MO, TU, ...\n              wday = rrule_RRule[day] // wday instanceof Weekday\n              options.byweekday.push(wday)\n            } else { // -1MO, +3FR, 1SO, ...\n              day = day.match(/^([+-]?\\d)([A-Z]{2})$/)\n              n = Number(day[1])\n              wday = day[2]\n              wday = rrule_RRule[wday].weekday\n              options.byweekday.push(new Weekday(wday, n))\n            }\n          }\n          break\n        case 'DTSTART':\n          options.dtstart = src_dateutil.untilStringToDate(value)\n          break\n        case 'UNTIL':\n          options.until = src_dateutil.untilStringToDate(value)\n          break\n        case 'BYEASTER':\n          options.byeaster = Number(value)\n          break\n        default:\n          throw new Error(\"Unknown RRULE property '\" + key + \"'\")\n      }\n    }\n    return options\n  }\n\n  static fromString (string) {\n    return new rrule_RRule(rrule_RRule.parseString(string))\n  }\n\n  static optionsToString (options) {\n    let key, value, strValues\n    const pairs = []\n    const keys = Object.keys(options)\n    const defaultKeys = Object.keys(rrule_RRule.DEFAULT_OPTIONS)\n\n    for (let i = 0; i < keys.length; i++) {\n      if (!Object(helpers[\"contains\"])(defaultKeys, keys[i])) continue\n\n      key = keys[i].toUpperCase()\n      value = options[keys[i]]\n      strValues = []\n\n      if (value === null || (value instanceof Array && !value.length)) continue\n\n      switch (key) {\n        case 'FREQ':\n          value = rrule_RRule.FREQUENCIES[options.freq]\n          break\n        case 'WKST':\n          if (!(value instanceof Weekday)) {\n            value = new Weekday(value)\n          }\n          break\n        case 'BYWEEKDAY':\n          /*\n          NOTE: BYWEEKDAY is a special case.\n          RRule() deconstructs the rule.options.byweekday array\n          into an array of Weekday arguments.\n          On the other hand, rule.origOptions is an array of Weekdays.\n          We need to handle both cases here.\n          It might be worth change RRule to keep the Weekdays.\n\n          Also, BYWEEKDAY (used by RRule) vs. BYDAY (RFC)\n\n          */\n          key = 'BYDAY'\n          if (!(value instanceof Array)) value = [value]\n\n          for (let wday, j = 0; j < value.length; j++) {\n            wday = value[j]\n            if (wday instanceof Weekday) {\n              // good\n            } else if (wday instanceof Array) {\n              wday = new Weekday(wday[0], wday[1])\n            } else {\n              wday = new Weekday(wday)\n            }\n            strValues[j] = wday.toString()\n          }\n          value = strValues\n          break\n        case 'DTSTART':\n        case 'UNTIL':\n          value = src_dateutil.timeToUntilString(value)\n          break\n        default:\n          if (value instanceof Array) {\n            for (let j = 0; j < value.length; j++) strValues[j] = String(value[j])\n            value = strValues\n          } else {\n            value = String(value)\n          }\n      }\n\n      pairs.push([key, value])\n    }\n\n    const strings = []\n    for (let i = 0; i < pairs.length; i++) {\n      const attr = pairs[i]\n      strings.push(attr[0] + '=' + attr[1].toString())\n    }\n    return strings.join(';')\n  }\n\n  /**\n   * @param {Function} iterator - optional function that will be called\n   *                   on each date that is added. It can return false\n   *                   to stop the iteration.\n   * @return Array containing all recurrences.\n   */\n  all (iterator) {\n    if (iterator) {\n      return this._iter(new callbackiterresult_CallbackIterResult('all', {}, iterator))\n    } else {\n      let result = this._cacheGet('all')\n      if (result === false) {\n        result = this._iter(new IterResult('all', {}))\n        this._cacheAdd('all', result)\n      }\n      return result\n    }\n  }\n\n  /**\n   * Returns all the occurrences of the rrule between after and before.\n   * The inc keyword defines what happens if after and/or before are\n   * themselves occurrences. With inc == True, they will be included in the\n   * list, if they are found in the recurrence set.\n   * @return Array\n   */\n  between (after, before, inc, iterator) {\n    const args = {\n      before: before,\n      after: after,\n      inc: inc\n    }\n\n    if (iterator) {\n      return this._iter(new callbackiterresult_CallbackIterResult('between', args, iterator))\n    }\n    let result = this._cacheGet('between', args)\n    if (result === false) {\n      result = this._iter(new IterResult('between', args))\n      this._cacheAdd('between', result, args)\n    }\n    return result\n  }\n\n  /**\n   * Returns the last recurrence before the given datetime instance.\n   * The inc keyword defines what happens if dt is an occurrence.\n   * With inc == True, if dt itself is an occurrence, it will be returned.\n   * @return Date or null\n   */\n  before (dt, inc) {\n    const args = {dt: dt, inc: inc}\n    let result = this._cacheGet('before', args)\n    if (result === false) {\n      result = this._iter(new IterResult('before', args))\n      this._cacheAdd('before', result, args)\n    }\n    return result\n  }\n\n  /**\n   * Returns the first recurrence after the given datetime instance.\n   * The inc keyword defines what happens if dt is an occurrence.\n   * With inc == True, if dt itself is an occurrence, it will be returned.\n   * @return Date or null\n   */\n  after (dt, inc) {\n    const args = {dt: dt, inc: inc}\n    let result = this._cacheGet('after', args)\n    if (result === false) {\n      result = this._iter(new IterResult('after', args))\n      this._cacheAdd('after', result, args)\n    }\n    return result\n  }\n\n  /**\n   * Returns the number of recurrences in this set. It will have go trough\n   * the whole recurrence, if this hasn't been done before.\n   */\n  count () {\n    return this.all().length\n  }\n\n  /**\n   * Converts the rrule into its string representation\n   * @see <http://www.ietf.org/rfc/rfc2445.txt>\n   * @return String\n   */\n  toString () {\n    return rrule_RRule.optionsToString(this.origOptions)\n  }\n\n  /**\n  * Will convert all rules described in nlp:ToText\n  * to text.\n  */\n  toText (gettext, language) {\n    return getnlp().toText(this, gettext, language)\n  }\n\n  isFullyConvertibleToText () {\n    return getnlp().isFullyConvertible(this)\n  }\n\n  /**\n   * @param {String} what - all/before/after/between\n   * @param {Array,Date} value - an array of dates, one date, or null\n   * @param {Object?} args - _iter arguments\n   */\n  _cacheAdd (what, value, args) {\n    if (!this._cache) return\n\n    if (value) {\n      value = (value instanceof Date)\n        ? src_dateutil.clone(value) : src_dateutil.cloneDates(value)\n    }\n\n    if (what === 'all') {\n      this._cache.all = value\n    } else {\n      args._value = value\n      this._cache[what].push(args)\n    }\n  }\n\n  /**\n   * @return false - not in the cache\n   *         null  - cached, but zero occurrences (before/after)\n   *         Date  - cached (before/after)\n   *         []    - cached, but zero occurrences (all/between)\n   *         [Date1, DateN] - cached (all/between)\n   */\n  _cacheGet (what, args) {\n    if (!this._cache) return false\n\n    let cached = false\n    const argsKeys = args ? Object.keys(args) : []\n    const findCacheDiff = function (item) {\n      for (let key, i = 0; i < argsKeys.length; i++) {\n        key = argsKeys[i]\n        if (String(args[key]) !== String(item[key])) return true\n      }\n      return false\n    }\n\n    if (what === 'all') {\n      cached = this._cache.all\n    } else {\n      // Let's see whether we've already called the\n      // 'what' method with the same 'args'\n      for (let item, i = 0; i < this._cache[what].length; i++) {\n        item = this._cache[what][i]\n        if (argsKeys.length && findCacheDiff(item)) continue\n        cached = item._value\n        break\n      }\n    }\n\n    if (!cached && this._cache.all) {\n      // Not in the cache, but we already know all the occurrences,\n      // so we can find the correct dates from the cached ones.\n      const iterResult = new IterResult(what, args)\n      for (let i = 0; i < this._cache.all.length; i++) {\n        if (!iterResult.accept(this._cache.all[i])) break\n      }\n      cached = iterResult.getValue()\n      this._cacheAdd(what, cached, args)\n    }\n\n    return cached instanceof Array\n      ? src_dateutil.cloneDates(cached)\n      : (cached instanceof Date ? src_dateutil.clone(cached) : cached)\n  }\n\n  /**\n   * @return a RRule instance with the same freq and options\n   *          as this one (cache is not cloned)\n   */\n  clone () {\n    return new rrule_RRule(this.origOptions)\n  }\n\n  _iter (iterResult) {\n    /* Since JavaScript doesn't have the python's yield operator (<1.7),\n        we use the IterResult object that tells us when to stop iterating.\n\n    */\n\n    const dtstart = this.options.dtstart\n    const dtstartMillisecondModulo = this.options.dtstart % 1000\n\n    let year = dtstart.getFullYear()\n    let month = dtstart.getMonth() + 1\n    let day = dtstart.getDate()\n    let hour = dtstart.getHours()\n    let minute = dtstart.getMinutes()\n    let second = dtstart.getSeconds()\n    let weekday = src_dateutil.getWeekday(dtstart)\n\n    // Some local variables to speed things up a bit\n    const freq = this.options.freq\n    const interval = this.options.interval\n    const wkst = this.options.wkst\n    const until = this.options.until\n    const bymonth = this.options.bymonth\n    const byweekno = this.options.byweekno\n    const byyearday = this.options.byyearday\n    const byweekday = this.options.byweekday\n    const byeaster = this.options.byeaster\n    const bymonthday = this.options.bymonthday\n    const bynmonthday = this.options.bynmonthday\n    const bysetpos = this.options.bysetpos\n    const byhour = this.options.byhour\n    const byminute = this.options.byminute\n    const bysecond = this.options.bysecond\n\n    const ii = new rrule_Iterinfo(this)\n    ii.rebuild(year, month)\n\n    const getdayset = {\n      [rrule_RRule.YEARLY]: ii.ydayset,\n      [rrule_RRule.MONTHLY]: ii.mdayset,\n      [rrule_RRule.WEEKLY]: ii.wdayset,\n      [rrule_RRule.DAILY]: ii.ddayset,\n      [rrule_RRule.HOURLY]: ii.ddayset,\n      [rrule_RRule.MINUTELY]: ii.ddayset,\n      [rrule_RRule.SECONDLY]: ii.ddayset\n    }[freq]\n\n    let timeset, gettimeset\n    if (freq < rrule_RRule.HOURLY) {\n      timeset = this.timeset\n    } else {\n      gettimeset = {\n        [rrule_RRule.HOURLY]: ii.htimeset,\n        [rrule_RRule.MINUTELY]: ii.mtimeset,\n        [rrule_RRule.SECONDLY]: ii.stimeset\n      }[freq]\n\n      if ((freq >= rrule_RRule.HOURLY && Object(helpers[\"plb\"])(byhour) && !Object(helpers[\"contains\"])(byhour, hour)) ||\n        (freq >= rrule_RRule.MINUTELY && Object(helpers[\"plb\"])(byminute) && !Object(helpers[\"contains\"])(byminute, minute)) ||\n        (freq >= rrule_RRule.SECONDLY && Object(helpers[\"plb\"])(bysecond) && !Object(helpers[\"contains\"])(bysecond, second))) {\n        timeset = []\n      } else {\n        timeset = gettimeset.call(ii, hour, minute, second, dtstartMillisecondModulo)\n      }\n    }\n\n    let total = 0\n    let count = this.options.count\n    let i, k, dm, div, mod, tmp, pos, dayset, start, end, fixday, filtered\n\n    while (true) {\n      // Get dayset with the right frequency\n      tmp = getdayset.call(ii, year, month, day)\n      dayset = tmp[0]\n      start = tmp[1]\n      end = tmp[2]\n\n      // Do the \"hard\" work ;-)\n      filtered = false\n      for (let j = start; j < end; j++) {\n        i = dayset[j]\n\n        filtered = (Object(helpers[\"plb\"])(bymonth) && !Object(helpers[\"contains\"])(bymonth, ii.mmask[i])) ||\n          (Object(helpers[\"plb\"])(byweekno) && !ii.wnomask[i]) ||\n          (Object(helpers[\"plb\"])(byweekday) && !Object(helpers[\"contains\"])(byweekday, ii.wdaymask[i])) ||\n          (Object(helpers[\"plb\"])(ii.nwdaymask) && !ii.nwdaymask[i]) ||\n          (byeaster !== null && !Object(helpers[\"contains\"])(ii.eastermask, i)) ||\n          ((Object(helpers[\"plb\"])(bymonthday) || Object(helpers[\"plb\"])(bynmonthday)) &&\n            !Object(helpers[\"contains\"])(bymonthday, ii.mdaymask[i]) &&\n            !Object(helpers[\"contains\"])(bynmonthday, ii.nmdaymask[i])) ||\n          (Object(helpers[\"plb\"])(byyearday) &&\n            ((i < ii.yearlen &&\n              !Object(helpers[\"contains\"])(byyearday, i + 1) &&\n              !Object(helpers[\"contains\"])(byyearday, -ii.yearlen + i)) ||\n            (i >= ii.yearlen &&\n              !Object(helpers[\"contains\"])(byyearday, i + 1 - ii.yearlen) &&\n              !Object(helpers[\"contains\"])(byyearday, -ii.nextyearlen + i - ii.yearlen))))\n\n        if (filtered) dayset[i] = null\n      }\n\n      // Output results\n      if (Object(helpers[\"plb\"])(bysetpos) && Object(helpers[\"plb\"])(timeset)) {\n        let daypos, timepos\n        const poslist = []\n\n        for (let i, j = 0; j < bysetpos.length; j++) {\n          pos = bysetpos[j]\n\n          if (pos < 0) {\n            daypos = Math.floor(pos / timeset.length)\n            timepos = Object(helpers[\"pymod\"])(pos, timeset.length)\n          } else {\n            daypos = Math.floor((pos - 1) / timeset.length)\n            timepos = Object(helpers[\"pymod\"])((pos - 1), timeset.length)\n          }\n\n          try {\n            tmp = []\n            for (k = start; k < end; k++) {\n              const val = dayset[k]\n              if (val === null) continue\n              tmp.push(val)\n            }\n            if (daypos < 0) {\n              // we're trying to emulate python's aList[-n]\n              i = tmp.slice(daypos)[0]\n            } else {\n              i = tmp[daypos]\n            }\n\n            const time = timeset[timepos]\n            const date = src_dateutil.fromOrdinal(ii.yearordinal + i)\n            const res = src_dateutil.combine(date, time)\n            // XXX: can this ever be in the array?\n            // - compare the actual date instead?\n            if (!Object(helpers[\"contains\"])(poslist, res)) poslist.push(res)\n          } catch (e) {}\n        }\n\n        src_dateutil.sort(poslist)\n        for (let j = 0; j < poslist.length; j++) {\n          const res = poslist[j]\n          if (until && res > until) {\n            this._len = total\n            return iterResult.getValue()\n          } else if (res >= dtstart) {\n            ++total\n            if (!iterResult.accept(res)) return iterResult.getValue()\n            if (count) {\n              --count\n              if (!count) {\n                this._len = total\n                return iterResult.getValue()\n              }\n            }\n          }\n        }\n      } else {\n        for (let j = start; j < end; j++) {\n          i = dayset[j]\n          if (i !== null) {\n            const date = src_dateutil.fromOrdinal(ii.yearordinal + i)\n            for (k = 0; k < timeset.length; k++) {\n              const time = timeset[k]\n              const res = src_dateutil.combine(date, time)\n              if (until && res > until) {\n                this._len = total\n                return iterResult.getValue()\n              } else if (res >= dtstart) {\n                ++total\n                if (!iterResult.accept(res)) return iterResult.getValue()\n                if (count) {\n                  --count\n                  if (!count) {\n                    this._len = total\n                    return iterResult.getValue()\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      // Handle frequency and interval\n      fixday = false\n      if (freq === rrule_RRule.YEARLY) {\n        year += interval\n        if (year > src_dateutil.MAXYEAR) {\n          this._len = total\n          return iterResult.getValue()\n        }\n        ii.rebuild(year, month)\n      } else if (freq === rrule_RRule.MONTHLY) {\n        month += interval\n        if (month > 12) {\n          div = Math.floor(month / 12)\n          mod = Object(helpers[\"pymod\"])(month, 12)\n          month = mod\n          year += div\n          if (month === 0) {\n            month = 12\n            --year\n          }\n          if (year > src_dateutil.MAXYEAR) {\n            this._len = total\n            return iterResult.getValue()\n          }\n        }\n        ii.rebuild(year, month)\n      } else if (freq === rrule_RRule.WEEKLY) {\n        if (wkst > weekday) {\n          day += -(weekday + 1 + (6 - wkst)) + interval * 7\n        } else {\n          day += -(weekday - wkst) + interval * 7\n        }\n        weekday = wkst\n        fixday = true\n      } else if (freq === rrule_RRule.DAILY) {\n        day += interval\n        fixday = true\n      } else if (freq === rrule_RRule.HOURLY) {\n        if (filtered) {\n          // Jump to one iteration before next day\n          hour += Math.floor((23 - hour) / interval) * interval\n        }\n        while (true) {\n          hour += interval\n          dm = Object(helpers[\"divmod\"])(hour, 24)\n          div = dm.div\n          mod = dm.mod\n          if (div) {\n            hour = mod\n            day += div\n            fixday = true\n          }\n          if (!Object(helpers[\"plb\"])(byhour) || Object(helpers[\"contains\"])(byhour, hour)) break\n        }\n        timeset = gettimeset.call(ii, hour, minute, second)\n      } else if (freq === rrule_RRule.MINUTELY) {\n        if (filtered) {\n          // Jump to one iteration before next day\n          minute += Math.floor(\n            (1439 - (hour * 60 + minute)) / interval) * interval\n        }\n\n        while (true) {\n          minute += interval\n          dm = Object(helpers[\"divmod\"])(minute, 60)\n          div = dm.div\n          mod = dm.mod\n          if (div) {\n            minute = mod\n            hour += div\n            dm = Object(helpers[\"divmod\"])(hour, 24)\n            div = dm.div\n            mod = dm.mod\n            if (div) {\n              hour = mod\n              day += div\n              fixday = true\n              filtered = false\n            }\n          }\n          if ((!Object(helpers[\"plb\"])(byhour) || Object(helpers[\"contains\"])(byhour, hour)) &&\n            (!Object(helpers[\"plb\"])(byminute) || Object(helpers[\"contains\"])(byminute, minute))) {\n            break\n          }\n        }\n        timeset = gettimeset.call(ii, hour, minute, second)\n      } else if (freq === rrule_RRule.SECONDLY) {\n        if (filtered) {\n          // Jump to one iteration before next day\n          second += Math.floor(\n            (86399 - (hour * 3600 + minute * 60 + second)) / interval) * interval\n        }\n        while (true) {\n          second += interval\n          dm = Object(helpers[\"divmod\"])(second, 60)\n          div = dm.div\n          mod = dm.mod\n          if (div) {\n            second = mod\n            minute += div\n            dm = Object(helpers[\"divmod\"])(minute, 60)\n            div = dm.div\n            mod = dm.mod\n            if (div) {\n              minute = mod\n              hour += div\n              dm = Object(helpers[\"divmod\"])(hour, 24)\n              div = dm.div\n              mod = dm.mod\n              if (div) {\n                hour = mod\n                day += div\n                fixday = true\n              }\n            }\n          }\n          if ((!Object(helpers[\"plb\"])(byhour) || Object(helpers[\"contains\"])(byhour, hour)) &&\n            (!Object(helpers[\"plb\"])(byminute) || Object(helpers[\"contains\"])(byminute, minute)) &&\n            (!Object(helpers[\"plb\"])(bysecond) || Object(helpers[\"contains\"])(bysecond, second))) {\n            break\n          }\n        }\n        timeset = gettimeset.call(ii, hour, minute, second)\n      }\n\n      if (fixday && day > 28) {\n        let daysinmonth = src_dateutil.monthRange(year, month - 1)[1]\n        if (day > daysinmonth) {\n          while (day > daysinmonth) {\n            day -= daysinmonth\n            ++month\n            if (month === 13) {\n              month = 1\n              ++year\n              if (year > src_dateutil.MAXYEAR) {\n                this._len = total\n                return iterResult.getValue()\n              }\n            }\n            daysinmonth = src_dateutil.monthRange(year, month - 1)[1]\n          }\n          ii.rebuild(year, month)\n        }\n      }\n    }\n  }\n}\n\n// RRule class 'constants'\n\nrrule_RRule.FREQUENCIES = [\n  'YEARLY', 'MONTHLY', 'WEEKLY', 'DAILY',\n  'HOURLY', 'MINUTELY', 'SECONDLY'\n]\n\nrrule_RRule.YEARLY = 0\nrrule_RRule.MONTHLY = 1\nrrule_RRule.WEEKLY = 2\nrrule_RRule.DAILY = 3\nrrule_RRule.HOURLY = 4\nrrule_RRule.MINUTELY = 5\nrrule_RRule.SECONDLY = 6\n\nrrule_RRule.MO = new Weekday(0)\nrrule_RRule.TU = new Weekday(1)\nrrule_RRule.WE = new Weekday(2)\nrrule_RRule.TH = new Weekday(3)\nrrule_RRule.FR = new Weekday(4)\nrrule_RRule.SA = new Weekday(5)\nrrule_RRule.SU = new Weekday(6)\n\nrrule_RRule.DEFAULT_OPTIONS = {\n  freq: null,\n  dtstart: null,\n  interval: 1,\n  wkst: rrule_RRule.MO,\n  count: null,\n  until: null,\n  bysetpos: null,\n  bymonth: null,\n  bymonthday: null,\n  bynmonthday: null,\n  byyearday: null,\n  byweekno: null,\n  byweekday: null,\n  bynweekday: null,\n  byhour: null,\n  byminute: null,\n  bysecond: null,\n  byeaster: null\n}\n\n// =============================================================================\n// Iterinfo\n// =============================================================================\n\nclass rrule_Iterinfo {\n  constructor (rrule) {\n    this.rrule = rrule\n    this.lastyear = null\n    this.lastmonth = null\n    this.yearlen = null\n    this.nextyearlen = null\n    this.yearordinal = null\n    this.yearweekday = null\n    this.mmask = null\n    this.mrange = null\n    this.mdaymask = null\n    this.nmdaymask = null\n    this.wdaymask = null\n    this.wnomask = null\n    this.nwdaymask = null\n    this.eastermask = null\n  }\n\n  easter (y, offset) {\n    offset = offset || 0\n\n    const a = y % 19\n    const b = Math.floor(y / 100)\n    const c = y % 100\n    const d = Math.floor(b / 4)\n    const e = b % 4\n    const f = Math.floor((b + 8) / 25)\n    const g = Math.floor((b - f + 1) / 3)\n    const h = Math.floor(19 * a + b - d - g + 15) % 30\n    const i = Math.floor(c / 4)\n    const k = c % 4\n    const l = Math.floor(32 + 2 * e + 2 * i - h - k) % 7\n    const m = Math.floor((a + 11 * h + 22 * l) / 451)\n    const month = Math.floor((h + l - 7 * m + 114) / 31)\n    const day = (h + l - 7 * m + 114) % 31 + 1\n    const date = Date.UTC(y, month - 1, day + offset)\n    const yearStart = Date.UTC(y, 0, 1)\n\n    return [Math.ceil((date - yearStart) / (1000 * 60 * 60 * 24))]\n  }\n\n  rebuild (year, month) {\n    const rr = this.rrule\n\n    if (year !== this.lastyear) {\n      this.yearlen = src_dateutil.isLeapYear(year) ? 366 : 365\n      this.nextyearlen = src_dateutil.isLeapYear(year + 1) ? 366 : 365\n      const firstyday = new Date(year, 0, 1)\n\n      this.yearordinal = src_dateutil.toOrdinal(firstyday)\n      this.yearweekday = src_dateutil.getWeekday(firstyday)\n\n      const wday = src_dateutil.getWeekday(new Date(year, 0, 1))\n\n      if (this.yearlen === 365) {\n        this.mmask = [].concat(M365MASK)\n        this.mdaymask = [].concat(MDAY365MASK)\n        this.nmdaymask = [].concat(NMDAY365MASK)\n        this.wdaymask = WDAYMASK.slice(wday)\n        this.mrange = [].concat(M365RANGE)\n      } else {\n        this.mmask = [].concat(M366MASK)\n        this.mdaymask = [].concat(MDAY366MASK)\n        this.nmdaymask = [].concat(NMDAY366MASK)\n        this.wdaymask = WDAYMASK.slice(wday)\n        this.mrange = [].concat(M366RANGE)\n      }\n\n      if (!Object(helpers[\"plb\"])(rr.options.byweekno)) {\n        this.wnomask = null\n      } else {\n        this.wnomask = Object(helpers[\"repeat\"])(0, this.yearlen + 7)\n        let no1wkst, firstwkst, wyearlen\n        no1wkst = firstwkst = Object(helpers[\"pymod\"])(7 - this.yearweekday + rr.options.wkst, 7)\n        if (no1wkst >= 4) {\n          no1wkst = 0\n          // Number of days in the year, plus the days we got\n          // from last year.\n          wyearlen = this.yearlen + Object(helpers[\"pymod\"])(this.yearweekday - rr.options.wkst, 7)\n        } else {\n          // Number of days in the year, minus the days we\n          // left in last year.\n          wyearlen = this.yearlen - no1wkst\n        }\n        const div = Math.floor(wyearlen / 7)\n        const mod = Object(helpers[\"pymod\"])(wyearlen, 7)\n        const numweeks = Math.floor(div + (mod / 4))\n        for (let n, i, j = 0; j < rr.options.byweekno.length; j++) {\n          n = rr.options.byweekno[j]\n          if (n < 0) {\n            n += numweeks + 1\n          } if (!(n > 0 && n <= numweeks)) {\n            continue\n          } if (n > 1) {\n            i = no1wkst + (n - 1) * 7\n            if (no1wkst !== firstwkst) {\n              i -= 7 - firstwkst\n            }\n          } else {\n            i = no1wkst\n          }\n          for (let k = 0; k < 7; k++) {\n            this.wnomask[i] = 1\n            i++\n            if (this.wdaymask[i] === rr.options.wkst) break\n          }\n        }\n\n        if (Object(helpers[\"contains\"])(rr.options.byweekno, 1)) {\n          // Check week number 1 of next year as well\n          // orig-TODO : Check -numweeks for next year.\n          let i = no1wkst + numweeks * 7\n          if (no1wkst !== firstwkst) i -= 7 - firstwkst\n          if (i < this.yearlen) {\n            // If week starts in next year, we\n            // don't care about it.\n            for (let j = 0; j < 7; j++) {\n              this.wnomask[i] = 1\n              i += 1\n              if (this.wdaymask[i] === rr.options.wkst) break\n            }\n          }\n        }\n\n        if (no1wkst) {\n          // Check last week number of last year as\n          // well. If no1wkst is 0, either the year\n          // started on week start, or week number 1\n          // got days from last year, so there are no\n          // days from last year's last week number in\n          // this year.\n          let lnumweeks\n          if (!Object(helpers[\"contains\"])(rr.options.byweekno, -1)) {\n            const lyearweekday = src_dateutil.getWeekday(new Date(year - 1, 0, 1))\n            let lno1wkst = Object(helpers[\"pymod\"])(7 - lyearweekday + rr.options.wkst, 7)\n            const lyearlen = src_dateutil.isLeapYear(year - 1) ? 366 : 365\n            if (lno1wkst >= 4) {\n              lno1wkst = 0\n              lnumweeks = Math.floor(52 +\n                Object(helpers[\"pymod\"])(lyearlen + Object(helpers[\"pymod\"])(lyearweekday - rr.options.wkst, 7), 7) / 4)\n            } else {\n              lnumweeks = Math.floor(52 + Object(helpers[\"pymod\"])(this.yearlen - no1wkst, 7) / 4)\n            }\n          } else {\n            lnumweeks = -1\n          }\n          if (Object(helpers[\"contains\"])(rr.options.byweekno, lnumweeks)) {\n            for (let i = 0; i < no1wkst; i++) this.wnomask[i] = 1\n          }\n        }\n      }\n    }\n\n    if (Object(helpers[\"plb\"])(rr.options.bynweekday) && (month !== this.lastmonth || year !== this.lastyear)) {\n      let ranges = []\n      if (rr.options.freq === rrule_RRule.YEARLY) {\n        if (Object(helpers[\"plb\"])(rr.options.bymonth)) {\n          for (let j = 0; j < rr.options.bymonth.length; j++) {\n            month = rr.options.bymonth[j]\n            ranges.push(this.mrange.slice(month - 1, month + 1))\n          }\n        } else {\n          ranges = [[0, this.yearlen]]\n        }\n      } else if (rr.options.freq === rrule_RRule.MONTHLY) {\n        ranges = [this.mrange.slice(month - 1, month + 1)]\n      }\n      if (Object(helpers[\"plb\"])(ranges)) {\n        // Weekly frequency won't get here, so we may not\n        // care about cross-year weekly periods.\n        this.nwdaymask = Object(helpers[\"repeat\"])(0, this.yearlen)\n\n        for (let j = 0; j < ranges.length; j++) {\n          const rang = ranges[j]\n          const first = rang[0]\n          let last = rang[1]\n          last -= 1\n          for (let k = 0; k < rr.options.bynweekday.length; k++) {\n            let i\n            const wday = rr.options.bynweekday[k][0]\n            const n = rr.options.bynweekday[k][1]\n            if (n < 0) {\n              i = last + (n + 1) * 7\n              i -= Object(helpers[\"pymod\"])(this.wdaymask[i] - wday, 7)\n            } else {\n              i = first + (n - 1) * 7\n              i += Object(helpers[\"pymod\"])(7 - this.wdaymask[i] + wday, 7)\n            }\n            if (first <= i && i <= last) this.nwdaymask[i] = 1\n          }\n        }\n      }\n\n      this.lastyear = year\n      this.lastmonth = month\n    }\n\n    if (rr.options.byeaster !== null) {\n      this.eastermask = this.easter(year, rr.options.byeaster)\n    }\n  }\n\n  ydayset (year, month, day) {\n    return [Object(helpers[\"range\"])(this.yearlen), 0, this.yearlen]\n  }\n\n  mdayset (year, month, day) {\n    const set = Object(helpers[\"repeat\"])(null, this.yearlen)\n    const start = this.mrange[month - 1]\n    const end = this.mrange[month]\n    for (let i = start; i < end; i++) set[i] = i\n    return [set, start, end]\n  }\n\n  wdayset (year, month, day) {\n    // We need to handle cross-year weeks here.\n    const set = Object(helpers[\"repeat\"])(null, this.yearlen + 7)\n    let i = src_dateutil.toOrdinal(new Date(year, month - 1, day)) - this.yearordinal\n    const start = i\n    for (let j = 0; j < 7; j++) {\n      set[i] = i\n      ++i\n      if (this.wdaymask[i] === this.rrule.options.wkst) break\n    }\n    return [set, start, i]\n  }\n\n  ddayset (year, month, day) {\n    const set = Object(helpers[\"repeat\"])(null, this.yearlen)\n    const i = src_dateutil.toOrdinal(new Date(year, month - 1, day)) - this.yearordinal\n    set[i] = i\n    return [set, i, i + 1]\n  }\n\n  htimeset (hour, minute, second, millisecond) {\n    const set = []\n    const rr = this.rrule\n    for (let i = 0; i < rr.options.byminute.length; i++) {\n      minute = rr.options.byminute[i]\n      for (let j = 0; j < rr.options.bysecond.length; j++) {\n        second = rr.options.bysecond[j]\n        set.push(new src_dateutil.Time(hour, minute, second, millisecond))\n      }\n    }\n    src_dateutil.sort(set)\n    return set\n  }\n\n  mtimeset (hour, minute, second, millisecond) {\n    const set = []\n    const rr = this.rrule\n    for (let j = 0; j < rr.options.bysecond.length; j++) {\n      second = rr.options.bysecond[j]\n      set.push(new src_dateutil.Time(hour, minute, second, millisecond))\n    }\n    src_dateutil.sort(set)\n    return set\n  }\n\n  stimeset (hour, minute, second, millisecond) {\n    return [new src_dateutil.Time(hour, minute, second, millisecond)]\n  }\n}\n\nfunction getnlp () {\n  // Lazy, runtime import to avoid circular refs.\n  if (!getnlp._nlp) {\n    getnlp._nlp = __webpack_require__(2)\n  }\n  return getnlp._nlp\n}\n\n// CONCATENATED MODULE: ./src/rruleset.js\n\n\n\n\n/**\n *\n * @param {Boolean?} noCache\n *  The same stratagy as RRule on cache, default to false\n * @constructor\n */\n\nclass rruleset_RRuleSet {\n  constructor (noCache) {\n    // Let RRuleSet cacheable\n    this._cache = noCache ? null : {\n      all: false,\n      before: [],\n      after: [],\n      between: []\n    }\n    this._rrule = []\n    this._rdate = []\n    this._exrule = []\n    this._exdate = []\n  }\n\n  /**\n  * @param {RRule}\n  */\n  rrule (rrule) {\n    if (!(rrule instanceof rrule_RRule)) {\n      throw new TypeError(String(rrule) + ' is not RRule instance')\n    }\n    if (!Object(helpers[\"contains\"])(this._rrule.map(String), String(rrule))) {\n      this._rrule.push(rrule)\n    }\n  }\n\n  /**\n  * @param {Date}\n  */\n  rdate (date) {\n    if (!(date instanceof Date)) {\n      throw new TypeError(String(date) + ' is not Date instance')\n    }\n    if (!Object(helpers[\"contains\"])(this._rdate.map(Number), Number(date))) {\n      this._rdate.push(date)\n      src_dateutil.sort(this._rdate)\n    }\n  }\n\n  /**\n  * @param {RRule}\n  */\n  exrule (rrule) {\n    if (!(rrule instanceof rrule_RRule)) {\n      throw new TypeError(String(rrule) + ' is not RRule instance')\n    }\n    if (!Object(helpers[\"contains\"])(this._exrule.map(String), String(rrule))) {\n      this._exrule.push(rrule)\n    }\n  }\n\n  /**\n  * @param {Date}\n  */\n  exdate (date) {\n    if (!(date instanceof Date)) {\n      throw new TypeError(String(date) + ' is not Date instance')\n    }\n    if (!Object(helpers[\"contains\"])(this._exdate.map(Number), Number(date))) {\n      this._exdate.push(date)\n      src_dateutil.sort(this._exdate)\n    }\n  }\n\n  valueOf () {\n    const result = []\n    if (this._rrule.length) {\n      this._rrule.forEach(function (rrule) {\n        result.push('RRULE:' + rrule)\n      })\n    }\n    if (this._rdate.length) {\n      result.push('RDATE:' + this._rdate.map(function (rdate) {\n        return src_dateutil.timeToUntilString(rdate)\n      }).join(','))\n    }\n    if (this._exrule.length) {\n      this._exrule.forEach(function (exrule) {\n        result.push('EXRULE:' + exrule)\n      })\n    }\n    if (this._exdate.length) {\n      result.push('EXDATE:' + this._exdate.map(function (exdate) {\n        return src_dateutil.timeToUntilString(exdate)\n      }).join(','))\n    }\n    return result\n  }\n\n  /**\n  * to generate recurrence field sush as:\n  *   [\"RRULE:FREQ=YEARLY;COUNT=2;BYDAY=TU;DTSTART=19970902T010000Z\",\"RRULE:FREQ=YEARLY;COUNT=1;BYDAY=TH;DTSTART=19970902T010000Z\"]\n  */\n  toString () {\n    return JSON.stringify(this.valueOf())\n  }\n\n  _iter (iterResult) {\n    const _exdateHash = {}\n    const _exrule = this._exrule\n    const _accept = iterResult.accept\n\n    function evalExdate (after, before) {\n      _exrule.forEach(function (rrule) {\n        rrule.between(after, before, true).forEach(function (date) {\n          _exdateHash[Number(date)] = true\n        })\n      })\n    }\n\n    this._exdate.forEach(function (date) {\n      _exdateHash[Number(date)] = true\n    })\n\n    iterResult.accept = function (date) {\n      const dt = Number(date)\n      if (!_exdateHash[dt]) {\n        evalExdate(new Date(dt - 1), new Date(dt + 1))\n        if (!_exdateHash[dt]) {\n          _exdateHash[dt] = true\n          return _accept.call(this, date)\n        }\n      }\n      return true\n    }\n\n    if (iterResult.method === 'between') {\n      evalExdate(iterResult.args.after, iterResult.args.before)\n      iterResult.accept = function (date) {\n        const dt = Number(date)\n        if (!_exdateHash[dt]) {\n          _exdateHash[dt] = true\n          return _accept.call(this, date)\n        }\n        return true\n      }\n    }\n\n    for (let i = 0; i < this._rdate.length; i++) {\n      if (!iterResult.accept(new Date(this._rdate[i]))) break\n    }\n\n    this._rrule.forEach(function (rrule) {\n      rrule._iter(iterResult)\n    })\n\n    const res = iterResult._result\n    src_dateutil.sort(res)\n    switch (iterResult.method) {\n      case 'all':\n      case 'between':\n        return res\n      case 'before':\n        return (res.length && res[res.length - 1]) || null\n      case 'after':\n        return (res.length && res[0]) || null\n      default:\n        return null\n    }\n  }\n\n  /**\n  * Create a new RRuleSet Object completely base on current instance\n  */\n  clone () {\n    const rrs = new rruleset_RRuleSet(!!this._cache)\n    let i\n    for (i = 0; i < this._rrule.length; i++) {\n      rrs.rrule(this._rrule[i].clone())\n    }\n    for (i = 0; i < this._rdate.length; i++) {\n      rrs.rdate(new Date(this._rdate[i]))\n    }\n    for (i = 0; i < this._exrule.length; i++) {\n      rrs.exrule(this._exrule[i].clone())\n    }\n    for (i = 0; i < this._exdate.length; i++) {\n      rrs.exdate(new Date(this._exdate[i]))\n    }\n    return rrs\n  }\n}\n\n/**\n * Inherts method from RRule\n *  add Read interface and set RRuleSet cacheable\n */\nconst RRuleSetMethods = ['all', 'between', 'before', 'after', 'count', '_cacheAdd', '_cacheGet']\nRRuleSetMethods.forEach(function (method) {\n  rruleset_RRuleSet.prototype[method] = rrule_RRule.prototype[method]\n})\n\n/* harmony default export */ var rruleset = (rruleset_RRuleSet);\n\n// CONCATENATED MODULE: ./src/rrulestr.js\n\n\n\n\n\n\n/**\n * RRuleStr\n *  To parse a set of rrule strings\n */\n\nclass rrulestr_RRuleStr {\n  _handle_int (rrkwargs, name, value, options) { // eslint-disable-line\n    rrkwargs[name.toLowerCase()] = parseInt(value, 10)\n  }\n\n  _handle_int_list (rrkwargs, name, value, options) { // eslint-disable-line\n    rrkwargs[name.toLowerCase()] = value.split(',').map(function (x) {\n      return parseInt(x, 10)\n    })\n  }\n\n  _handle_FREQ (rrkwargs, name, value, options) { // eslint-disable-line\n    rrkwargs['freq'] = rrulestr_RRuleStr._freq_map[value]\n  }\n\n  _handle_UNTIL (rrkwargs, name, value, options) { // eslint-disable-line\n    try {\n      rrkwargs['until'] = src_dateutil.untilStringToDate(value)\n    } catch (error) {\n      throw new Error('invalid until date')\n    }\n  }\n\n  _handle_WKST (rrkwargs, name, value, options) { // eslint-disable-line\n    rrkwargs['wkst'] = rrulestr_RRuleStr._weekday_map[value]\n  }\n\n  _handle_BYWEEKDAY (rrkwargs, name, value, options) { // eslint-disable-line\n    // Two ways to specify this: +1MO or MO(+1)\n    let splt, i, j, n, w, wday\n    const l = []\n    const wdays = value.split(',')\n\n    for (i = 0; i < wdays.length; i++) {\n      wday = wdays[i]\n      if (wday.indexOf('(') > -1) {\n        // If it's of the form TH(+1), etc.\n        splt = wday.split('(')\n        w = splt[0]\n        n = parseInt(splt.slice(1, -1), 10)\n      } else {\n        // # If it's of the form +1MO\n        for (j = 0; j < wday.length; j++) {\n          if ('+-0123456789'.indexOf(wday[j]) === -1) break\n        }\n        n = wday.slice(0, j) || null\n        w = wday.slice(j)\n\n        if (n) n = parseInt(n, 10)\n      }\n\n      const weekday = new Weekday(rrulestr_RRuleStr._weekday_map[w], n)\n      l.push(weekday)\n    }\n    rrkwargs['byweekday'] = l\n  }\n\n  _parseRfcRRule (line, options) {\n    options = options || {}\n    options.dtstart = options.dtstart || null\n    options.cache = options.cache || false\n    options.ignoretz = options.ignoretz || false\n    options.tzinfos = options.tzinfos || null\n\n    let name, value, parts\n    if (line.indexOf(':') !== -1) {\n      parts = line.split(':')\n      name = parts[0]\n      value = parts[1]\n\n      if (name !== 'RRULE') throw new Error('unknown parameter name')\n    } else {\n      value = line\n    }\n\n    let i\n    const rrkwargs = {}\n    const pairs = value.split(';')\n\n    for (i = 0; i < pairs.length; i++) {\n      parts = pairs[i].split('=')\n      name = parts[0].toUpperCase()\n      value = parts[1].toUpperCase()\n\n      try {\n        this['_handle_' + name](rrkwargs, name, value, {\n          ignoretz: options.ignoretz,\n          tzinfos: options.tzinfos\n        })\n      } catch (error) {\n        throw new Error(\"unknown parameter '\" + name + \"':\" + value)\n      }\n    }\n    rrkwargs.dtstart = rrkwargs.dtstart || options.dtstart\n    return new rrule_RRule(rrkwargs, !options.cache)\n  }\n\n  _parseRfc (s, options) {\n    if (options.compatible) {\n      options.forceset = true\n      options.unfold = true\n    }\n\n    s = s && s.toUpperCase().trim()\n    if (!s) throw new Error('Invalid empty string')\n\n    let i = 0\n    let line, lines\n\n    // More info about 'unfold' option\n    // Go head to http://www.ietf.org/rfc/rfc2445.txt\n    if (options.unfold) {\n      lines = s.split('\\n')\n      while (i < lines.length) {\n        // TODO\n        line = lines[i] = lines[i].replace(/\\s+$/g, '')\n        if (!line) {\n          lines.splice(i, 1)\n        } else if (i > 0 && line[0] === ' ') {\n          lines[i - 1] += line.slice(1)\n          lines.splice(i, 1)\n        } else {\n          i += 1\n        }\n      }\n    } else {\n      lines = s.split(/\\s/)\n    }\n\n    const rrulevals = []\n    const rdatevals = []\n    const exrulevals = []\n    const exdatevals = []\n    let name, value, parts, parms, parm, dtstart, rset, j, k, datestrs, datestr\n\n    if (!options.forceset && lines.length === 1 && (s.indexOf(':') === -1 ||\n      s.indexOf('RRULE:') === 0)) {\n      return this._parseRfcRRule(lines[0], {\n        cache: options.cache,\n        dtstart: options.dtstart,\n        ignoretz: options.ignoretz,\n        tzinfos: options.tzinfos\n      })\n    } else {\n      for (let i = 0; i < lines.length; i++) {\n        line = lines[i]\n        if (!line) continue\n        if (line.indexOf(':') === -1) {\n          name = 'RRULE'\n          value = line\n        } else {\n          parts = Object(helpers[\"split\"])(line, ':', 1)\n          name = parts[0]\n          value = parts[1]\n        }\n        parms = name.split(';')\n        if (!parms) throw new Error('empty property name')\n        name = parms[0]\n        parms = parms.slice(1)\n\n        if (name === 'RRULE') {\n          for (j = 0; j < parms.length; j++) {\n            parm = parms[j]\n            throw new Error('unsupported RRULE parm: ' + parm)\n          }\n          rrulevals.push(value)\n        } else if (name === 'RDATE') {\n          for (j = 0; j < parms.length; j++) {\n            parm = parms[j]\n            if (parm !== 'VALUE=DATE-TIME' && parm !== 'VALUE=DATE') {\n              throw new Error('unsupported RDATE parm: ' + parm)\n            }\n          }\n          rdatevals.push(value)\n        } else if (name === 'EXRULE') {\n          for (j = 0; j < parms.length; j++) {\n            parm = parms[j]\n            throw new Error('unsupported EXRULE parm: ' + parm)\n          }\n          exrulevals.push(value)\n        } else if (name === 'EXDATE') {\n          for (j = 0; j < parms.length; j++) {\n            parm = parms[j]\n            if (parm !== 'VALUE=DATE-TIME' && parm !== 'VALUE=DATE') {\n              throw new Error('unsupported EXDATE parm: ' + parm)\n            }\n          }\n          exdatevals.push(value)\n        } else if (name === 'DTSTART') {\n          dtstart = src_dateutil.untilStringToDate(value)\n        } else {\n          throw new Error('unsupported property: ' + name)\n        }\n      }\n\n      if (options.forceset || rrulevals.length > 1 || rdatevals.length ||\n        exrulevals.length || exdatevals.length) {\n        rset = new rruleset(!options.cache)\n        for (j = 0; j < rrulevals.length; j++) {\n          rset.rrule(this._parseRfcRRule(rrulevals[j], {\n            dtstart: options.dtstart || dtstart,\n            ignoretz: options.ignoretz,\n            tzinfos: options.tzinfos\n          }))\n        }\n        for (j = 0; j < rdatevals.length; j++) {\n          datestrs = rdatevals[j].split(',')\n          for (k = 0; k < datestrs.length; k++) {\n            datestr = datestrs[k]\n            rset.rdate(src_dateutil.untilStringToDate(datestr))\n          }\n        }\n        for (j = 0; j < exrulevals.length; j++) {\n          rset.exrule(this._parseRfcRRule(exrulevals[j], {\n            dtstart: options.dtstart || dtstart,\n            ignoretz: options.ignoretz,\n            tzinfos: options.tzinfos\n          }))\n        }\n        for (j = 0; j < exdatevals.length; j++) {\n          datestrs = exdatevals[j].split(',')\n          for (k = 0; k < datestrs.length; k++) {\n            datestr = datestrs[k]\n            rset.exdate(src_dateutil.untilStringToDate(datestr))\n          }\n        }\n\n        if (options.campatiable && options.dtstart) rset.rdate(dtstart)\n        return rset\n      } else {\n        return this._parseRfcRRule(rrulevals[0], {\n          dtstart: options.dtstart || dtstart,\n          cache: options.cache,\n          ignoretz: options.ignoretz,\n          tzinfos: options.tzinfos\n        })\n      }\n    }\n  }\n\n  parse (s, options) {\n    options = options || {}\n\n    const invalid = []\n    const keys = Object.keys(options)\n    const defaultKeys = Object.keys(rrulestr_RRuleStr.DEFAULT_OPTIONS)\n\n    keys.forEach(function (key) {\n      if (!Object(helpers[\"contains\"])(defaultKeys, key)) invalid.push(key)\n    }, this)\n\n    if (invalid.length) throw new Error('Invalid options: ' + invalid.join(', '))\n\n    // Merge in default options\n    defaultKeys.forEach(function (key) {\n      if (!Object(helpers[\"contains\"])(keys, key)) options[key] = rrulestr_RRuleStr.DEFAULT_OPTIONS[key]\n    })\n\n    return this._parseRfc(s, options)\n  }\n}\n\nrrulestr_RRuleStr.DEFAULT_OPTIONS = {\n  dtstart: null,\n  cache: false,\n  unfold: false,\n  forceset: false,\n  compatible: false,\n  ignoretz: false,\n  tzinfos: null\n}\n\nrrulestr_RRuleStr._freq_map = {\n  'YEARLY': rrule_RRule.YEARLY,\n  'MONTHLY': rrule_RRule.MONTHLY,\n  'WEEKLY': rrule_RRule.WEEKLY,\n  'DAILY': rrule_RRule.DAILY,\n  'HOURLY': rrule_RRule.HOURLY,\n  'MINUTELY': rrule_RRule.MINUTELY,\n  'SECONDLY': rrule_RRule.SECONDLY\n}\n\nrrulestr_RRuleStr._weekday_map = {\n  'MO': 0,\n  'TU': 1,\n  'WE': 2,\n  'TH': 3,\n  'FR': 4,\n  'SA': 5,\n  'SU': 6\n}\n\nrrulestr_RRuleStr.prototype._handle_DTSTART = function (rrkwargs, name, value, options) {\n  rrkwargs[name.toLowerCase()] = src_dateutil.untilStringToDate(value)\n}\n\nrrulestr_RRuleStr.prototype._handle_BYDAY = rrulestr_RRuleStr.prototype._handle_BYWEEKDAY\nrrulestr_RRuleStr.prototype._handle_INTERVAL = rrulestr_RRuleStr.prototype._handle_int\nrrulestr_RRuleStr.prototype._handle_COUNT = rrulestr_RRuleStr.prototype._handle_int\n\n;[\n  '_handle_BYSETPOS', '_handle_BYMONTH', '_handle_BYMONTHDAY',\n  '_handle_BYYEARDAY', '_handle_BYEASTER', '_handle_BYWEEKNO',\n  '_handle_BYHOUR', '_handle_BYMINUTE', '_handle_BYSECOND'\n].forEach(function (method) {\n  rrulestr_RRuleStr.prototype[method] = rrulestr_RRuleStr.prototype._handle_int_list\n})\n\n/* harmony default export */ var rrulestr = (rrulestr_RRuleStr);\n\n// CONCATENATED MODULE: ./src/index.js\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rrulestr\", function() { return src_rrulestr; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"RRule\", function() { return rrule_RRule; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"RRuleSet\", function() { return rruleset; });\n/*!\n * rrule.js - Library for working with recurrence rules for calendar dates.\n * https://github.com/jakubroztocil/rrule\n *\n * Copyright 2010, Jakub Roztocil and Lars Schoning\n * Licenced under the BSD licence.\n * https://github.com/jakubroztocil/rrule/blob/master/LICENCE\n *\n * Based on:\n * python-dateutil - Extensions to the standard Python datetime module.\n * Copyright (c) 2003-2011 - Gustavo Niemeyer <gustavo@niemeyer.net>\n * Copyright (c) 2012 - Tomi Pieviläinen <tomi.pievilainen@iki.fi>\n * https://github.com/jakubroztocil/rrule/blob/master/LICENCE\n *\n */\n\n\n\n\n\n// =============================================================================\n// Export\n// =============================================================================\n\n// Only one RRuleStr instance for all rrule string parsing work.\nconst rruleStr = new rrulestr()\nconst src_rrulestr = function () {\n  return rruleStr.parse.apply(rruleStr, arguments)\n}\n\n\n\nrrule_RRule.RRule = rrule_RRule\nrrule_RRule.RRuleSet = rruleset\nrrule_RRule.rrulestr = src_rrulestr\n\n/* harmony default export */ var src = __webpack_exports__[\"default\"] = (rrule_RRule);\n\n\n//# sourceURL=webpack://rrule/./src/index.js_+_8_modules?")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./src/nlp/i18n.js\n// =============================================================================\n// i18n\n// =============================================================================\n\nconst ENGLISH = {\n  dayNames: [\n    'Sunday', 'Monday', 'Tuesday', 'Wednesday',\n    'Thursday', 'Friday', 'Saturday'\n  ],\n  monthNames: [\n    'January', 'February', 'March', 'April', 'May',\n    'June', 'July', 'August', 'September', 'October',\n    'November', 'December'\n  ],\n  tokens: {\n    'SKIP': /^[ \\r\\n\\t]+|^\\.$/,\n    'number': /^[1-9][0-9]*/,\n    'numberAsText': /^(one|two|three)/i,\n    'every': /^every/i,\n    'day(s)': /^days?/i,\n    'weekday(s)': /^weekdays?/i,\n    'week(s)': /^weeks?/i,\n    'hour(s)': /^hours?/i,\n    'minute(s)': /^minutes?/i,\n    'month(s)': /^months?/i,\n    'year(s)': /^years?/i,\n    'on': /^(on|in)/i,\n    'at': /^(at)/i,\n    'the': /^the/i,\n    'first': /^first/i,\n    'second': /^second/i,\n    'third': /^third/i,\n    'nth': /^([1-9][0-9]*)(\\.|th|nd|rd|st)/i,\n    'last': /^last/i,\n    'for': /^for/i,\n    'time(s)': /^times?/i,\n    'until': /^(un)?til/i,\n    'monday': /^mo(n(day)?)?/i,\n    'tuesday': /^tu(e(s(day)?)?)?/i,\n    'wednesday': /^we(d(n(esday)?)?)?/i,\n    'thursday': /^th(u(r(sday)?)?)?/i,\n    'friday': /^fr(i(day)?)?/i,\n    'saturday': /^sa(t(urday)?)?/i,\n    'sunday': /^su(n(day)?)?/i,\n    'january': /^jan(uary)?/i,\n    'february': /^feb(ruary)?/i,\n    'march': /^mar(ch)?/i,\n    'april': /^apr(il)?/i,\n    'may': /^may/i,\n    'june': /^june?/i,\n    'july': /^july?/i,\n    'august': /^aug(ust)?/i,\n    'september': /^sep(t(ember)?)?/i,\n    'october': /^oct(ober)?/i,\n    'november': /^nov(ember)?/i,\n    'december': /^dec(ember)?/i,\n    'comma': /^(,\\s*|(and|or)\\s*)+/i\n  }\n}\n\n/* harmony default export */ var i18n = (ENGLISH);\n\n// EXTERNAL MODULE: ./src/index.js + 8 modules\nvar src = __webpack_require__(1);\n\n// CONCATENATED MODULE: ./src/nlp/totext.js\n\n\n\n// =============================================================================\n// Helper functions\n// =============================================================================\n\n/**\n * Return true if a value is in an array\n */\nconst contains = function (arr, val) {\n  return arr.indexOf(val) !== -1\n}\n\n// =============================================================================\n// ToText\n// =============================================================================\n\n/**\n *\n * @param {RRule} rrule\n * Optional:\n * @param {Function} gettext function\n * @param {Object} language definition\n * @constructor\n */\nclass totext_ToText {\n  constructor (rrule, gettext, language) {\n    this.text = ''\n    this.language = language || i18n\n    this.gettext = gettext || function (id) {\n      return id\n    }\n\n    this.rrule = rrule\n    this.freq = rrule.options.freq\n    this.options = rrule.options\n    this.origOptions = rrule.origOptions\n\n    if (this.origOptions.bymonthday) {\n      const bymonthday = [].concat(this.options.bymonthday)\n      const bynmonthday = [].concat(this.options.bynmonthday)\n\n      bymonthday.sort()\n      bynmonthday.sort()\n      bynmonthday.reverse()\n      // 1, 2, 3, .., -5, -4, -3, ..\n      this.bymonthday = bymonthday.concat(bynmonthday)\n      if (!this.bymonthday.length) this.bymonthday = null\n    }\n\n    if (this.origOptions.byweekday) {\n      const byweekday = !(this.origOptions.byweekday instanceof Array)\n        ? [this.origOptions.byweekday] : this.origOptions.byweekday\n      const days = String(byweekday)\n\n      this.byweekday = {\n        allWeeks: byweekday.filter(function (weekday) {\n          return !weekday.n\n        }),\n        someWeeks: byweekday.filter(function (weekday) {\n          return Boolean(weekday.n)\n        }),\n        isWeekdays: (\n          days.indexOf('MO') !== -1 &&\n          days.indexOf('TU') !== -1 &&\n          days.indexOf('WE') !== -1 &&\n          days.indexOf('TH') !== -1 &&\n          days.indexOf('FR') !== -1 &&\n          days.indexOf('SA') === -1 &&\n          days.indexOf('SU') === -1\n        )\n      }\n\n      const sortWeekDays = function (a, b) {\n        return a.weekday - b.weekday\n      }\n\n      this.byweekday.allWeeks.sort(sortWeekDays)\n      this.byweekday.someWeeks.sort(sortWeekDays)\n\n      if (!this.byweekday.allWeeks.length) this.byweekday.allWeeks = null\n      if (!this.byweekday.someWeeks.length) this.byweekday.someWeeks = null\n    } else {\n      this.byweekday = null\n    }\n  }\n\n  /**\n   * Test whether the rrule can be fully converted to text.\n   * @param {RRule} rrule\n   * @return {Boolean}\n   */\n  static isFullyConvertible (rrule) {\n    let canConvert = true\n\n    if (!(rrule.options.freq in totext_ToText.IMPLEMENTED)) return false\n    if (rrule.origOptions.until && rrule.origOptions.count) return false\n\n    for (let key in rrule.origOptions) {\n      if (contains(['dtstart', 'wkst', 'freq'], key)) return true\n      if (!contains(totext_ToText.IMPLEMENTED[rrule.options.freq], key)) return false\n    }\n\n    return canConvert\n  }\n\n  isFullyConvertible () {\n    return totext_ToText.isFullyConvertible(this.rrule)\n  }\n\n  /**\n   * Perform the conversion. Only some of the frequencies are supported.\n   * If some of the rrule's options aren't supported, they'll\n   * be omitted from the output an \"(~ approximate)\" will be appended.\n   * @return {*}\n   */\n  toString () {\n    const gettext = this.gettext\n\n    if (!(this.options.freq in totext_ToText.IMPLEMENTED)) {\n      return gettext('RRule error: Unable to fully convert this rrule to text')\n    }\n\n    this.text = [gettext('every')]\n    this[src[\"default\"].FREQUENCIES[this.options.freq]]()\n\n    if (this.options.until) {\n      this.add(gettext('until'))\n      const until = this.options.until\n      this.add(this.language.monthNames[until.getMonth()])\n        .add(until.getDate() + ',')\n        .add(until.getFullYear())\n    } else if (this.options.count) {\n      this.add(gettext('for'))\n        .add(this.options.count)\n        .add(this.plural(this.options.count)\n          ? gettext('times') : gettext('time'))\n    }\n\n    if (!this.isFullyConvertible()) this.add(gettext('(~ approximate)'))\n\n    return this.text.join('')\n  }\n\n  HOURLY () {\n    const gettext = this.gettext\n\n    if (this.options.interval !== 1) this.add(this.options.interval)\n\n    this.add(this.plural(this.options.interval)\n      ? gettext('hours') : gettext('hour'))\n  }\n\n  MINUTELY () {\n    const gettext = this.gettext\n\n    if (this.options.interval !== 1) this.add(this.options.interval)\n\n    this.add(this.plural(this.options.interval)\n      ? gettext('minutes') : gettext('minutes'))\n  }\n\n  DAILY () {\n    const gettext = this.gettext\n\n    if (this.options.interval !== 1) this.add(this.options.interval)\n\n    if (this.byweekday && this.byweekday.isWeekdays) {\n      this.add(this.plural(this.options.interval)\n        ? gettext('weekdays') : gettext('weekday'))\n    } else {\n      this.add(this.plural(this.options.interval)\n        ? gettext('days') : gettext('day'))\n    }\n\n    if (this.origOptions.bymonth) {\n      this.add(gettext('in'))\n      this._bymonth()\n    }\n\n    if (this.bymonthday) {\n      this._bymonthday()\n    } else if (this.byweekday) {\n      this._byweekday()\n    } else if (this.origOptions.byhour) {\n      this._byhour()\n    }\n  }\n\n  WEEKLY () {\n    const gettext = this.gettext\n\n    if (this.options.interval !== 1) {\n      this.add(this.options.interval)\n        .add(this.plural(this.options.interval)\n          ? gettext('weeks') : gettext('week'))\n    }\n\n    if (this.byweekday && this.byweekday.isWeekdays) {\n      if (this.options.interval === 1) {\n        this.add(this.plural(this.options.interval)\n          ? gettext('weekdays') : gettext('weekday'))\n      } else {\n        this.add(gettext('on')).add(gettext('weekdays'))\n      }\n    } else {\n      if (this.options.interval === 1) this.add(gettext('week'))\n\n      if (this.origOptions.bymonth) {\n        this.add(gettext('in'))\n        this._bymonth()\n      }\n\n      if (this.bymonthday) {\n        this._bymonthday()\n      } else if (this.byweekday) {\n        this._byweekday()\n      }\n    }\n  }\n\n  MONTHLY () {\n    const gettext = this.gettext\n\n    if (this.origOptions.bymonth) {\n      if (this.options.interval !== 1) {\n        this.add(this.options.interval).add(gettext('months'))\n        if (this.plural(this.options.interval)) this.add(gettext('in'))\n      } else {\n        // this.add(gettext('MONTH'))\n      }\n      this._bymonth()\n    } else {\n      if (this.options.interval !== 1) this.add(this.options.interval)\n      this.add(this.plural(this.options.interval)\n        ? gettext('months') : gettext('month'))\n    }\n    if (this.bymonthday) {\n      this._bymonthday()\n    } else if (this.byweekday && this.byweekday.isWeekdays) {\n      this.add(gettext('on')).add(gettext('weekdays'))\n    } else if (this.byweekday) {\n      this._byweekday()\n    }\n  }\n\n  YEARLY () {\n    const gettext = this.gettext\n\n    if (this.origOptions.bymonth) {\n      if (this.options.interval !== 1) {\n        this.add(this.options.interval)\n        this.add(gettext('years'))\n      } else {\n        // this.add(gettext('YEAR'))\n      }\n      this._bymonth()\n    } else {\n      if (this.options.interval !== 1) this.add(this.options.interval)\n      this.add(this.plural(this.options.interval)\n        ? gettext('years') : gettext('year'))\n    }\n\n    if (this.bymonthday) {\n      this._bymonthday()\n    } else if (this.byweekday) {\n      this._byweekday()\n    }\n\n    if (this.options.byyearday) {\n      this.add(gettext('on the'))\n        .add(this.list(this.options.byyearday, this.nth, gettext('and')))\n        .add(gettext('day'))\n    }\n\n    if (this.options.byweekno) {\n      this.add(gettext('in'))\n        .add(this.plural(this.options.byweekno.length) ? gettext('weeks') : gettext('week'))\n        .add(this.list(this.options.byweekno, null, gettext('and')))\n    }\n  }\n\n  _bymonthday () {\n    const gettext = this.gettext\n    if (this.byweekday && this.byweekday.allWeeks) {\n      this.add(gettext('on'))\n        .add(this.list(this.byweekday.allWeeks, this.weekdaytext, gettext('or')))\n        .add(gettext('the'))\n        .add(this.list(this.bymonthday, this.nth, gettext('or')))\n    } else {\n      this.add(gettext('on the'))\n        .add(this.list(this.bymonthday, this.nth, gettext('and')))\n    }\n    // this.add(gettext('DAY'))\n  }\n\n  _byweekday () {\n    const gettext = this.gettext\n    if (this.byweekday.allWeeks && !this.byweekday.isWeekdays) {\n      this.add(gettext('on'))\n        .add(this.list(this.byweekday.allWeeks, this.weekdaytext))\n    }\n\n    if (this.byweekday.someWeeks) {\n      if (this.byweekday.allWeeks) this.add(gettext('and'))\n\n      this.add(gettext('on the'))\n        .add(this.list(this.byweekday.someWeeks, this.weekdaytext, gettext('and')))\n    }\n  }\n\n  _byhour () {\n    const gettext = this.gettext\n\n    this.add(gettext('at'))\n      .add(this.list(this.origOptions.byhour, null, gettext('and')))\n  }\n\n  _bymonth () {\n    this.add(this.list(this.options.bymonth, this.monthtext, this.gettext('and')))\n  }\n\n  nth (n) {\n    let nth, npos\n    const gettext = this.gettext\n\n    if (n === -1) return gettext('last')\n\n    npos = Math.abs(n)\n    switch (npos) {\n      case 1:\n      case 21:\n      case 31:\n        nth = npos + gettext('st')\n        break\n      case 2:\n      case 22:\n        nth = npos + gettext('nd')\n        break\n      case 3:\n      case 23:\n        nth = npos + gettext('rd')\n        break\n      default:\n        nth = npos + gettext('th')\n    }\n\n    return n < 0 ? nth + ' ' + gettext('last') : nth\n  }\n\n  monthtext (m) {\n    return this.language.monthNames[m - 1]\n  }\n\n  weekdaytext (wday) {\n    const weekday = typeof wday === 'number' ? (wday + 1) % 7 : wday.getJsWeekday()\n    return (wday.n ? this.nth(wday.n) + ' ' : '') +\n      this.language.dayNames[weekday]\n  }\n\n  plural (n) {\n    return n % 100 !== 1\n  }\n\n  add (s) {\n    this.text.push(' ')\n    this.text.push(s)\n    return this\n  }\n\n  list (arr, callback, finalDelim, delim) {\n    if (!(arr instanceof Array)) {\n      arr = [arr]\n    }\n    const delimJoin = function (array, delimiter, finalDelimiter) {\n      let list = ''\n\n      for (let i = 0; i < array.length; i++) {\n        if (i !== 0) {\n          if (i === array.length - 1) {\n            list += ' ' + finalDelimiter + ' '\n          } else {\n            list += delimiter + ' '\n          }\n        }\n        list += array[i]\n      }\n      return list\n    }\n\n    delim = delim || ','\n    callback = callback || function (o) {\n      return o\n    }\n    const self = this\n    const realCallback = function (arg) {\n      return callback.call(self, arg)\n    }\n\n    if (finalDelim) {\n      return delimJoin(arr.map(realCallback), delim, finalDelim)\n    } else {\n      return arr.map(realCallback).join(delim + ' ')\n    }\n  }\n}\n\n// CONCATENATED MODULE: ./src/nlp/parsetext.js\n\n\n\nconst parseText = function (text, language) {\n  const options = {}\n  const ttr = new Parser((language || i18n).tokens)\n\n  if (!ttr.start(text)) return null\n\n  S()\n  return options\n\n  function S () {\n    // every [n]\n    let n\n\n    ttr.expect('every')\n    if ((n = ttr.accept('number'))) options.interval = parseInt(n[0], 10)\n    if (ttr.isDone()) throw new Error('Unexpected end')\n\n    switch (ttr.symbol) {\n      case 'day(s)':\n        options.freq = src[\"default\"].DAILY\n        if (ttr.nextSymbol()) {\n          AT()\n          F()\n        }\n        break\n\n      // FIXME Note: every 2 weekdays != every two weeks on weekdays.\n      // DAILY on weekdays is not a valid rule\n      case 'weekday(s)':\n        options.freq = src[\"default\"].WEEKLY\n        options.byweekday = [\n          src[\"default\"].MO,\n          src[\"default\"].TU,\n          src[\"default\"].WE,\n          src[\"default\"].TH,\n          src[\"default\"].FR\n        ]\n        ttr.nextSymbol()\n        F()\n        break\n\n      case 'week(s)':\n        options.freq = src[\"default\"].WEEKLY\n        if (ttr.nextSymbol()) {\n          ON()\n          F()\n        }\n        break\n\n      case 'hour(s)':\n        options.freq = src[\"default\"].HOURLY\n        if (ttr.nextSymbol()) {\n          ON()\n          F()\n        }\n        break\n\n      case 'minute(s)':\n        options.freq = src[\"default\"].MINUTELY\n        if (ttr.nextSymbol()) {\n          ON()\n          F()\n        }\n        break\n\n      case 'month(s)':\n        options.freq = src[\"default\"].MONTHLY\n        if (ttr.nextSymbol()) {\n          ON()\n          F()\n        }\n        break\n\n      case 'year(s)':\n        options.freq = src[\"default\"].YEARLY\n        if (ttr.nextSymbol()) {\n          ON()\n          F()\n        }\n        break\n\n      case 'monday':\n      case 'tuesday':\n      case 'wednesday':\n      case 'thursday':\n      case 'friday':\n      case 'saturday':\n      case 'sunday':\n        options.freq = src[\"default\"].WEEKLY\n        options.byweekday = [src[\"default\"][ttr.symbol.substr(0, 2).toUpperCase()]]\n\n        if (!ttr.nextSymbol()) return\n\n        // TODO check for duplicates\n        while (ttr.accept('comma')) {\n          if (ttr.isDone()) throw new Error('Unexpected end')\n\n          let wkd\n          if (!(wkd = decodeWKD())) {\n            throw new Error('Unexpected symbol ' + ttr.symbol + ', expected weekday')\n          }\n\n          options.byweekday.push(src[\"default\"][wkd])\n          ttr.nextSymbol()\n        }\n        MDAYs()\n        F()\n        break\n\n      case 'january':\n      case 'february':\n      case 'march':\n      case 'april':\n      case 'may':\n      case 'june':\n      case 'july':\n      case 'august':\n      case 'september':\n      case 'october':\n      case 'november':\n      case 'december':\n        options.freq = src[\"default\"].YEARLY\n        options.bymonth = [decodeM()]\n\n        if (!ttr.nextSymbol()) return\n\n        // TODO check for duplicates\n        while (ttr.accept('comma')) {\n          if (ttr.isDone()) throw new Error('Unexpected end')\n\n          let m\n          if (!(m = decodeM())) {\n            throw new Error('Unexpected symbol ' + ttr.symbol + ', expected month')\n          }\n\n          options.bymonth.push(m)\n          ttr.nextSymbol()\n        }\n\n        ON()\n        F()\n        break\n\n      default:\n        throw new Error('Unknown symbol')\n    }\n  }\n\n  function ON () {\n    const on = ttr.accept('on')\n    const the = ttr.accept('the')\n    if (!(on || the)) return\n\n    do {\n      let nth, wkd, m\n\n      // nth <weekday> | <weekday>\n      if ((nth = decodeNTH())) {\n        // ttr.nextSymbol()\n\n        if ((wkd = decodeWKD())) {\n          ttr.nextSymbol()\n          if (!options.byweekday) options.byweekday = []\n          options.byweekday.push(src[\"default\"][wkd].nth(nth))\n        } else {\n          if (!options.bymonthday) options.bymonthday = []\n          options.bymonthday.push(nth)\n          ttr.accept('day(s)')\n        }\n        // <weekday>\n      } else if ((wkd = decodeWKD())) {\n        ttr.nextSymbol()\n        if (!options.byweekday) options.byweekday = []\n        options.byweekday.push(src[\"default\"][wkd])\n      } else if (ttr.symbol === 'weekday(s)') {\n        ttr.nextSymbol()\n        if (!options.byweekday) options.byweekday = []\n        options.byweekday.push(src[\"default\"].MO)\n        options.byweekday.push(src[\"default\"].TU)\n        options.byweekday.push(src[\"default\"].WE)\n        options.byweekday.push(src[\"default\"].TH)\n        options.byweekday.push(src[\"default\"].FR)\n      } else if (ttr.symbol === 'week(s)') {\n        ttr.nextSymbol()\n        let n\n        if (!(n = ttr.accept('number'))) {\n          throw new Error('Unexpected symbol ' + ttr.symbol + ', expected week number')\n        }\n        options.byweekno = [n[0]]\n        while (ttr.accept('comma')) {\n          if (!(n = ttr.accept('number'))) {\n            throw new Error('Unexpected symbol ' + ttr.symbol + '; expected monthday')\n          }\n          options.byweekno.push(n[0])\n        }\n      } else if ((m = decodeM())) {\n        ttr.nextSymbol()\n        if (!options.bymonth) options.bymonth = []\n        options.bymonth.push(m)\n      } else {\n        return\n      }\n    } while (ttr.accept('comma') || ttr.accept('the') || ttr.accept('on'))\n  }\n\n  function AT () {\n    const at = ttr.accept('at')\n    if (!at) return\n\n    do {\n      let n\n      if (!(n = ttr.accept('number'))) {\n        throw new Error('Unexpected symbol ' + ttr.symbol + ', expected hour')\n      }\n      options.byhour = [n[0]]\n      while (ttr.accept('comma')) {\n        if (!(n = ttr.accept('number'))) {\n          throw new Error('Unexpected symbol ' + ttr.symbol + '; expected hour')\n        }\n        options.byhour.push(n[0])\n      }\n    } while (ttr.accept('comma') || ttr.accept('at'))\n  }\n\n  function decodeM () {\n    switch (ttr.symbol) {\n      case 'january':\n        return 1\n      case 'february':\n        return 2\n      case 'march':\n        return 3\n      case 'april':\n        return 4\n      case 'may':\n        return 5\n      case 'june':\n        return 6\n      case 'july':\n        return 7\n      case 'august':\n        return 8\n      case 'september':\n        return 9\n      case 'october':\n        return 10\n      case 'november':\n        return 11\n      case 'december':\n        return 12\n      default:\n        return false\n    }\n  }\n\n  function decodeWKD () {\n    switch (ttr.symbol) {\n      case 'monday':\n      case 'tuesday':\n      case 'wednesday':\n      case 'thursday':\n      case 'friday':\n      case 'saturday':\n      case 'sunday':\n        return ttr.symbol.substr(0, 2).toUpperCase()\n      default:\n        return false\n    }\n  }\n\n  function decodeNTH () {\n    switch (ttr.symbol) {\n      case 'last':\n        ttr.nextSymbol()\n        return -1\n      case 'first':\n        ttr.nextSymbol()\n        return 1\n      case 'second':\n        ttr.nextSymbol()\n        return ttr.accept('last') ? -2 : 2\n      case 'third':\n        ttr.nextSymbol()\n        return ttr.accept('last') ? -3 : 3\n      case 'nth':\n        const v = parseInt(ttr.value[1], 10)\n        if (v < -366 || v > 366) throw new Error('Nth out of range: ' + v)\n\n        ttr.nextSymbol()\n        return ttr.accept('last') ? -v : v\n\n      default:\n        return false\n    }\n  }\n\n  function MDAYs () {\n    ttr.accept('on')\n    ttr.accept('the')\n\n    let nth\n    if (!(nth = decodeNTH())) return\n\n    options.bymonthday = [nth]\n    ttr.nextSymbol()\n\n    while (ttr.accept('comma')) {\n      if (!(nth = decodeNTH())) {\n        throw new Error('Unexpected symbol ' + ttr.symbol + '; expected monthday')\n      }\n\n      options.bymonthday.push(nth)\n      ttr.nextSymbol()\n    }\n  }\n\n  function F () {\n    if (ttr.symbol === 'until') {\n      const date = Date.parse(ttr.text)\n\n      if (!date) throw new Error('Cannot parse until date:' + ttr.text)\n      options.until = new Date(date)\n    } else if (ttr.accept('for')) {\n      options.count = ttr.value[0]\n      ttr.expect('number')\n      // ttr.expect('times')\n    }\n  }\n}\n\n// =============================================================================\n// Parser\n// =============================================================================\n\nclass Parser {\n  constructor (rules) {\n    this.rules = rules\n  }\n\n  start (text) {\n    this.text = text\n    this.done = false\n    return this.nextSymbol()\n  }\n\n  isDone () {\n    return this.done && this.symbol == null\n  }\n\n  nextSymbol () {\n    let best, bestSymbol\n    const p = this\n\n    this.symbol = null\n    this.value = null\n    do {\n      if (this.done) return false\n\n      let match, rule\n      best = null\n      for (let name in this.rules) {\n        rule = this.rules[name]\n        if ((match = rule.exec(p.text))) {\n          if (best == null || match[0].length > best[0].length) {\n            best = match\n            bestSymbol = name\n          }\n        }\n      }\n\n      if (best != null) {\n        this.text = this.text.substr(best[0].length)\n\n        if (this.text === '') this.done = true\n      }\n\n      if (best == null) {\n        this.done = true\n        this.symbol = null\n        this.value = null\n        return\n      }\n    } while (bestSymbol === 'SKIP')\n\n    this.symbol = bestSymbol\n    this.value = best\n    return true\n  }\n\n  accept (name) {\n    if (this.symbol === name) {\n      if (this.value) {\n        const v = this.value\n        this.nextSymbol()\n        return v\n      }\n\n      this.nextSymbol()\n      return true\n    }\n\n    return false\n  }\n\n  expect (name) {\n    if (this.accept(name)) return true\n\n    throw new Error('expected ' + name + ' but found ' + this.symbol)\n  }\n}\n\n/* harmony default export */ var parsetext = (parseText);\n\n// CONCATENATED MODULE: ./src/nlp/index.js\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromText\", function() { return fromText; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isFullyConvertible\", function() { return isFullyConvertible; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toText\", function() { return toText; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"parseText\", function() { return parsetext; });\n\n\n\n\n/*!\n* rrule.js - Library for working with recurrence rules for calendar dates.\n* https://github.com/jakubroztocil/rrule\n*\n* Copyright 2010, Jakub Roztocil and Lars Schoning\n* Licenced under the BSD licence.\n* https://github.com/jakubroztocil/rrule/blob/master/LICENCE\n*\n*/\n\n/**\n *\n * Implementation of RRule.fromText() and RRule::toText().\n *\n *\n * On the client side, this file needs to be included\n * when those functions are used.\n *\n */\n\n// =============================================================================\n// fromText\n// =============================================================================\n/**\n * Will be able to convert some of the below described rules from\n * text format to a rule object.\n *\n *\n * RULES\n *\n * Every ([n])\n *       day(s)\n *     | [weekday], ..., (and) [weekday]\n *     | weekday(s)\n *     | week(s)\n *     | month(s)\n *     | [month], ..., (and) [month]\n *     | year(s)\n *\n *\n * Plus 0, 1, or multiple of these:\n *\n * on [weekday], ..., (or) [weekday] the [monthday], [monthday], ... (or) [monthday]\n *\n * on [weekday], ..., (and) [weekday]\n *\n * on the [monthday], [monthday], ... (and) [monthday] (day of the month)\n *\n * on the [nth-weekday], ..., (and) [nth-weekday] (of the month/year)\n *\n *\n * Plus 0 or 1 of these:\n *\n * for [n] time(s)\n *\n * until [date]\n *\n * Plus (.)\n *\n *\n * Definitely no supported for parsing:\n *\n * (for year):\n *     in week(s) [n], ..., (and) [n]\n *\n *     on the [yearday], ..., (and) [n] day of the year\n *     on day [yearday], ..., (and) [n]\n *\n *\n * NON-TERMINALS\n *\n * [n]: 1, 2 ..., one, two, three ..\n * [month]: January, February, March, April, May, ... December\n * [weekday]: Monday, ... Sunday\n * [nth-weekday]: first [weekday], 2nd [weekday], ... last [weekday], ...\n * [monthday]: first, 1., 2., 1st, 2nd, second, ... 31st, last day, 2nd last day, ..\n * [date]:\n *     [month] (0-31(,) ([year])),\n *     (the) 0-31.(1-12.([year])),\n *     (the) 0-31/(1-12/([year])),\n *     [weekday]\n *\n * [year]: 0000, 0001, ... 01, 02, ..\n *\n * Definitely not supported for parsing:\n *\n * [yearday]: first, 1., 2., 1st, 2nd, second, ... 366th, last day, 2nd last day, ..\n *\n * @param {String} text\n * @return {Object, Boolean} the rule, or null.\n */\nconst fromText = function (text, language) {\n  return new src[\"default\"](parsetext(text, language))\n}\n\nconst common = [\n  'count', 'until', 'interval',\n  'byweekday', 'bymonthday', 'bymonth'\n]\n\ntotext_ToText.IMPLEMENTED = []\ntotext_ToText.IMPLEMENTED[src[\"default\"].HOURLY] = common\ntotext_ToText.IMPLEMENTED[src[\"default\"].MINUTELY] = common\ntotext_ToText.IMPLEMENTED[src[\"default\"].DAILY] = ['byhour'].concat(common)\ntotext_ToText.IMPLEMENTED[src[\"default\"].WEEKLY] = common\ntotext_ToText.IMPLEMENTED[src[\"default\"].MONTHLY] = common\ntotext_ToText.IMPLEMENTED[src[\"default\"].YEARLY] = ['byweekno', 'byyearday'].concat(common)\n\n// =============================================================================\n// Export\n// =============================================================================\n\nconst toText = function (rrule, gettext, language) {\n  return new totext_ToText(rrule, gettext, language).toString()\n}\n\nconst { isFullyConvertible } = totext_ToText\n\n\n\n\n//# sourceURL=webpack://rrule/./src/nlp/index.js_+_3_modules?")}])});